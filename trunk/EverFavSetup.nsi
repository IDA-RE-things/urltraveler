; Script generated by the HM NIS Edit Script Wizard.
RequestExecutionLevel admin
; HM NIS Edit Wizard helper defines

!include WinVer.nsh
!include LogicLib.nsh
!include Library.nsh
!include nsDialogs.nsh
!include FileFunc.nsh
!include DirRequestExt.nsh

/*******************************************类型声明*******************************************************/
; 下面代码拷贝自!include "${NSISDIR}\Examples\System\System.nsh"
; 由于System.nsh和nsDialogs.nsh有冲突所以只好抽一部分数据类型出来
; typedef struct _RECT { 
;   LONG left; 
;   LONG top; 
;   LONG right; 
;   LONG bottom; 
; } RECT, *PRECT; 
!define stRECT "(i, i, i, i) i"

!define SWP_NOSIZE          0x0001
!define SWP_NOMOVE          0x0002
/***********************************************************************************************************/

/**
可变,存放待打包源文件的目录
这里为相对本文件(RainbowSetup.nsi)位置的相对路径
*/
!define SRC_DIR               ".\bin"            

!define PRODUCT_NAME          "EverFav"
!define PRODUCT_NAME_CHINESE  "EverFav 云端收藏夹"

;!define PRODUCT_VERSION       "1.0"      ;可变，版本号
!define PRODUCT_VERSION       "正式版"      ;可变，版本号
;!define PRODUCT_VERSION_INFO  "1.0.0.000"    ;可变，完整的版本信息
!define PRODUCT_VERSION_INFO  "1.0.0.0"    ;可变，完整的版本信息


;设置输出文件名和安装目录
;Name "${PRODUCT_NAME} ${PRODUCT_VERSION}" "${PRODUCT_NAME}"
;Name "${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION}" "${PRODUCT_NAME_CHINESE}"
Name "${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION}" "${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION}"
;OutFile "CaiHongSetup_${PRODUCT_VERSION_INFO}_Beta090227.exe"
;OutFile "EverFavSetup_${PRODUCT_VERSION_INFO}_Beta1(${__DATE__}).exe"
OutFile "EverFavSetup_${PRODUCT_VERSION_INFO}_Beta1.exe"

InstallDir "$PROGRAMFILES\EverFav"
ShowInstDetails hide
ShowUnInstDetails hide

!define PRODUCT_PUBLISHER     "www.everfav.com"
!define PRODUCT_WEB_SITE      "http://www.everfav.com/index.php"

!define PRODUCT_UNINST_KEY    "Software\Microsoft\Windows\CurrentVersion\Uninstall\${PRODUCT_NAME}"
!define PRODUCT_UNINST_ROOT_KEY "HKLM"

!define CORE_WINDOW_TITLE     "EverFav"
!define UPDATE_WINDOW_TITLE   L"EverFav在线升级"
!define PRODUCT_WINDOW_TITLE  "EverFav"

!define PRODUCT_INST_KEY      "Software\3+\${PRODUCT_NAME}"
!define PRODUCT_INST_ROOT_KEY "HKLM"

;51挂挂的产品名称
;!define PRODUCT_51GG_NAME "51GG"
;51挂挂的注册路径
;!define PRODUCT_51GG_INST_KEY "Software\51Corp\${PRODUCT_51GG_NAME}"

/***********************************************************************************
下面是界面上各个按钮的Caption的设置
***********************************************************************************/

; 安装时的Dialog Title
!define TITLE "${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION} 安装"
; 卸载时的Dialog Title
!define UNTITLE "${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION} 卸载"
/*
; Text to display on the 'I Agree' button.
!define MUI_LICENSEPAGE_BUTTON "我同意(&I)"
; 替换反安装按钮的文字
UninstallButtonText "解除安装(&U)"
*/
; 替换当文件无法被写入时的警告窗的文字
; FileErrorText "无法写入文件$\r$\n$0$\r$\n请确认文件属性不是只读且未被使用中！"

/***********************************************************************************
***********************************************************************************/

; 使用 WindowsXP 视觉样式 
XPstyle On 

; 执行 CRC 检查（最好用 on 打开。关闭是因为还要修改安装程序，看第 10 步）
CRCCheck on

; 不卸载相应的控件
SetPluginUnload  alwaysoff

;Request application privileges for Windows Vista
;RequestExecutionLevel user

Var InstallDirForPhotoUploader

/**设置压缩算法和相应参数,下面取消/SOLID参数为了避免Vista下弹出创建一临时文件的提示
但是带来了降低了压缩比率的代价
*/
;SetCompressor /SOLID /FINAL lzma 
;SetCompressor /FINAL lzma 

;设置数据优化,避免安装程序中包含多个一样的文件
SetDatablockOptimize on

;设置安装路径
InstallDirRegKey ${PRODUCT_INST_ROOT_KEY} "${PRODUCT_INST_KEY}" "Install"

!define MUI_CUSTOMFUNCTION_GUIINIT OnGUIInit
!define MUI_CUSTOMFUNCTION_UNGUIINIT un.OnUNGUIInit

; MUI 1.67 compatible ------
!include "MUI.nsh"
!include MUI2.nsh
;!include DirRequestExt.nsh

; MUI Settings
!define MUI_ABORTWARNING

/**
; 图标，logo位图等
!define MUI_ICON "logo\IMSetup.ico"
!define MUI_UNICON "logo\IMUninstall.ico"
!define MUI_WELCOMEFINISHPAGE_BITMAP "logo\Welcome.bmp"
!define MUI_HEADERIMAGE
!define MUI_HEADERIMAGE_RIGHT
!define MUI_HEADERIMAGE_BITMAP "logo\Logo.bmp"
;!define MUI_HEADERIMAGE_BITMAP_NOSTRETCH
!define MUI_UNWELCOMEFINISHPAGE_BITMAP "logo\Welcome.bmp"
;!define MUI_HEADER_TRANSPARENT_TEXT
*/

; Welcome page
BrandingText /TRIMLEFT "www.everfav.com/index.php"
!define MUI_WELCOMEFINISHPAGE_CUSTOMFUNCTION_INIT OnWelcomePageInit
!define MUI_PAGE_CUSTOMFUNCTION_PRE OnWelcomePagePre
!insertmacro MUI_PAGE_WELCOME

; License page
!define MUI_PAGE_CUSTOMFUNCTION_PRE OnLicencePagePre
!insertmacro MUI_PAGE_LICENSE "${SRC_DIR}\License.txt"

; Custom Directory page
Page custom OnCustomDirectoryPageCreate OnCustomDirectoryPageLeave

; Directory page
;!define MUI_PAGE_CUSTOMFUNCTION_PRE OnDirectoryPagePre
;!define MUI_PAGE_CUSTOMFUNCTION_SHOW OnDirectoryPageShow
;!define MUI_PAGE_CUSTOMFUNCTION_LEAVE OnDirectoryPageLeave
;!insertmacro MUI_PAGE_DIRECTORY

; Instfiles page
!define MUI_PAGE_CUSTOMFUNCTION_SHOW OnInstfilesPageShow
!define MUI_PAGE_CUSTOMFUNCTION_LEAVE OnInstfilesPageLeave
!insertmacro MUI_PAGE_INSTFILES

; Finish page
!define MUI_FINISHPAGE_RUN "$INSTDIR\EverFav.exe"
;!define MUI_FINISHPAGE_SHOWREADME "$INSTDIR\Features.txt"
!define MUI_PAGE_CUSTOMFUNCTION_PRE OnFinishPagePre
!define MUI_PAGE_CUSTOMFUNCTION_SHOW OnFinishPageShow
!define MUI_PAGE_CUSTOMFUNCTION_LEAVE OnFinishPageLeave
!insertmacro MUI_PAGE_FINISH


/*******************************************全局变量*******************************************************/
Var IsInstalledAlready        ;是否已经安装了Rainbow
Var InstalledPath             ;已经安装的路径
Var InstallToPath             ;将要安装的路径
Var IsRainbowWebDllInUse      ;rainbowweb.dll是否被(ie)使用
/**彩虹的安装版本类型,
-2  :表没有安装过彩虹
-1  :表示原来低版本现安装高版本, 
==0 :表示同级版本, 
> 0 :表示原来高版本现在低版本
*/
Var RainbowInstallVersionType    
Var RdoBtn_MyDocument_Folder          ;个人数据选择文件路径那个RadioButton的Handle
Var RdoBtn_MyDocument_Folder_State    ;个人数据选择文件路径，本次要安装的
Var Old_RdoBtn_MyDocument_Folder_State  ;上次版本的个人数据选择文件路径
Var IsGGInstalledAlready              ;是否已经安装了51GG
Var GGInstalledPath                   ;51GG安装目录
Var PersonalDataPath                  ;个人数字文件夹的目录

/*********************************************下面是全局宏定义**********************************************/

###############################################################
# 函数: StrStrI,本函数拷贝自蓝色网际的UseFulLib.nsh
###############################################################
!macro INSERT_FUNC_LITE_StrStrI OUTPUT STRING TOSREACH
  Push `${TOSREACH}`
  Push `${STRING}`
  System::Call "Shlwapi::StrStrI(t, t) t (s, s) .s"
  Pop ${OUTPUT}
!macroend
!define StrStrI '!insertmacro INSERT_FUNC_LITE_StrStrI'
###############################################################

###############################################################
/** 本宏定义检测Path是否为系统目录
@param in:Path,传入的路径
@param out:PathResult,对应的系统目录子串
@param out:Result,输出的的结果值，1:是系统路径，0:不是系统路径
*/
!define CHECKSYSPATH_NOTSYS 0
!define CHECKSYSPATH_SYS    1
Var CheckSysPathResult
Var CheckSysPathPathResult
!macro CheckSysPath Path PathResult Result
  ;Save existing register values to the stack
  Call PushAllGlobalVariable 
  
  ;本函数使用的全局变量初始化
  IntOp $CheckSysPathResult ${CHECKSYSPATH_NOTSYS} + 0
  StrCpy $CheckSysPathPathResult ""

  ; 检测是否为系统目录
  ; 结果: $0 = Windows\explorer.exe
  ${StrStrI} $0 "${Path}" "$PROGRAMFILES"
  ${If} $0 == ""
    ${StrStrI} $0 "${Path}" "$WINDIR"
    ${If} $0 == ""
      ${StrStrI} $0 "${Path}" "$SYSDIR" 
      ${If} $0 == ""
        ${StrStrI} $0 "${Path}" "$TEMP" 
        ${If} $0 == ""
          ${StrStrI} $0 "${Path}" "$PROGRAMFILES64" 
          ${If} $0 == ""
            IntOp $CheckSysPathResult ${CHECKSYSPATH_NOTSYS} + 0
            ;MessageBox MB_OK "Debug:${Path},$0"
          ${Else}
            IntOp $CheckSysPathResult ${CHECKSYSPATH_SYS} + 0
            StrCpy $CheckSysPathPathResult "$PROGRAMFILES64"
            ;MessageBox MB_OK "Debug:${Path},$0"
          ${EndIf}
        ${Else}
          IntOp $CheckSysPathResult ${CHECKSYSPATH_SYS} + 0
          StrCpy $CheckSysPathPathResult "$TEMP"
          ;MessageBox MB_OK "Debug:${Path},$0"
        ${EndIf}
      ${Else}
        IntOp $CheckSysPathResult ${CHECKSYSPATH_SYS} + 0
        StrCpy $CheckSysPathPathResult "$SYSDIR"
        ;MessageBox MB_OK "Debug:${Path},$0"
      ${EndIf}
    ${Else}
      IntOp $CheckSysPathResult ${CHECKSYSPATH_SYS} + 0
      StrCpy $CheckSysPathPathResult "$WINDIR"
      ;MessageBox MB_OK "Debug:${Path},$0"
    ${EndIf}
  ${Else}
      IntOp $CheckSysPathResult ${CHECKSYSPATH_SYS} + 0
      StrCpy $CheckSysPathPathResult "$PROGRAMFILES"
      ;MessageBox MB_OK "Debug:${Path},$0"
  ${EndIf}

  ;Restore register values from the stack
  Call PopAllGlobalVariable
  
  StrCpy ${PathResult} $CheckSysPathPathResult 
  IntOp ${Result} $CheckSysPathResult + 0
!macroend
###############################################################

###############################################################
/** 本宏定义对于太大的值(超过2的31次方，因为此时将变成负数)将计算出错
@param in:sizeIn,传入的大小为Byte的值
@param out:textSizeOut,输出的的Text值
*/
Var GetSizeTextTempVariable
!macro GetSizeTextByByte sizeIn textSizeOut
  ;Save existing register values to the stack
  Call PushAllGlobalVariable  

  ;本函数使用的全局变量初始化
  StrCpy $GetSizeTextTempVariable ""

  ;这里要采用64位的运算函数 L> 才行
  ${If} ${sizeIn} L> 1073741824
    ;大小为G的级别,下面除以1024*1024变为M的单位
    ;这里要采用64位的运算函数System::Int64Op才行
    System::Int64Op ${sizeIn} / 1048576 
    Pop $0
    
    IntOp $1 $0 / 1024 
    IntOP $2 $0 % 1024 
    IntOp $3 $2 * 1000
    IntOp $4 $3 / 1024 
    StrCpy $GetSizeTextTempVariable "$1.$4GB"
  ${ElseIf} ${sizeIn} > 1048576
    ;大小为M的级别,下面除以1024变为KB的单位
    IntOp $0 ${sizeIn} / 1024 

    IntOp $1 $0 / 1024 
    IntOP $2 $0 % 1024 
    IntOp $3 $2 * 1000
    IntOp $4 $3 / 1024 
    StrCpy $GetSizeTextTempVariable "$1.$4MB"
  ${ElseIf} ${sizeIn} > 1024
    ;大小为KB的级别
    IntOp $0 ${sizeIn} / 1024 
    IntOP $1 ${sizeIn} % 1024 
    IntOp $2 $1 * 1000
    IntOp $3 $2 / 1024 
    StrCpy $GetSizeTextTempVariable "$0.$3KB"
  ${ElseIf} ${sizeIn} > 0
    StrCpy $GetSizeTextTempVariable "${sizeIn}B"  
  ${Else}
    StrCpy $GetSizeTextTempVariable "0B" 
  ${EndIf}

  ;Restore register values from the stack
  Call PopAllGlobalVariable

  StrCpy ${textSizeOut} $GetSizeTextTempVariable
  ;MessageBox MB_OK "Debug:${textSizeOut}"
!macroend
###############################################################

###############################################################
/** 本宏检测目录的有效性,比如无效的盘符等
@param in:Path,传入的Path
@param out:Result,输出的的结果0:表有效:,1:表无效,2:路径为空
*/
!define CHECKPATH_OK       0
!define CHECKPATH_INVALID  1
!define CHECKPATH_EMPTY    2
Var CheckPathTempVariable
!macro CheckPath Path Result
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ;本函数使用的全局变量初始化
  IntOp $CheckPathTempVariable ${CHECKPATH_OK} + 0

  ;检测目录的有效性
  ;IfFileExists "目录\*.*" 
  ${If} ${Path} == ""
    IntOP $CheckPathTempVariable ${CHECKPATH_EMPTY} + 0
  ${ElseIf} ${FileExists} "${Path}\*.*"
    ;MessageBox MB_OK "Debug:${Path}\*.*"    
    IntOP $CheckPathTempVariable ${CHECKPATH_OK} + 0
  ${Else}
    ;检测该盘符是否是有效的
    ${GetRoot} ${Path} $0
    ${DriveSpace} "$0" "/D=F /S=B" $R0
    ;MessageBox MB_OK "Debug:$R0"
    ${If} $R0 == "" 
      ;是无效的盘符，因为空间是0
      IntOP $CheckPathTempVariable ${CHECKPATH_INVALID} + 0
      ;MessageBox MB_OK "Debug:是无效的盘符，因为空间是0"
    ${ElseIf} $R0 == 0
      ;是无效的盘符，因为空间是0
      IntOP $CheckPathTempVariable ${CHECKPATH_INVALID} + 0
    ${Else}
      IntOP $CheckPathTempVariable ${CHECKPATH_OK} + 0
    ${EndIf}
  ${EndIf} 

  ;Restore register values from the stack
  Call PopAllGlobalVariable

  IntOp ${Result} $CheckPathTempVariable + 0
!macroend
###############################################################

###############################################################
/** 本宏检测目录的是否含有非法字符
1.如首字符是/或\。
2.含有: * ? " < > |
@param in:Path,传入的Path
@param out:Result,输出的的结果0:表有效,1:首字符为/或\,2:表含有: * ? " < > |
*/
!define CHECKPATHSYMBOL_OK              0
!define CHECKPATHSYMBOL_FIRST_CHAR      1
!define CHECKPATHSYMBOL_SPECIAL_CHAR    2
Var CheckPathSymbolTempVariable
!macro CheckPathSymbol Path Result
  ;Save existing register values to the stack
  Call PushAllGlobalVariable
  
  ;本函数使用的全局变量初始化
  IntOP $CheckPathSymbolTempVariable ${CHECKPATHSYMBOL_OK} + 0

  ;检测首字符是否为\ 
  ${StrStrI} $0 ${Path} "\"
  ${If} $0 == ${Path}
    IntOp $CheckPathSymbolTempVariable ${CHECKPATHSYMBOL_FIRST_CHAR} + 0
  ${EndIf}
  
  ;检测首字符是否为/
  ${If} $CheckPathSymbolTempVariable == ${CHECKPATHSYMBOL_OK}
    ${StrStrI} $0 ${Path} "/"
    ${If} $0 == ${Path}
      IntOp $CheckPathSymbolTempVariable ${CHECKPATHSYMBOL_FIRST_CHAR} + 0
    ${EndIf}
  ${EndIf}
  
  ;检测路径中是否包含"*"
  ${If} $CheckPathSymbolTempVariable == ${CHECKPATHSYMBOL_OK}
    ${StrStrI} $0 ${Path} "*"
    ${If} $0 != ""
      IntOp $CheckPathSymbolTempVariable ${CHECKPATHSYMBOL_SPECIAL_CHAR} + 0
    ${EndIf}
  ${EndIf}

  ;检测路径中是否包含"?"
  ${If} $CheckPathSymbolTempVariable == ${CHECKPATHSYMBOL_OK}
    ${StrStrI} $0 ${Path} "?"
    ${If} $0 != ""
      IntOp $CheckPathSymbolTempVariable ${CHECKPATHSYMBOL_SPECIAL_CHAR} + 0
    ${EndIf}
  ${EndIf}

  ;检测路径中是否包含"""
  ${If} $CheckPathSymbolTempVariable == ${CHECKPATHSYMBOL_OK}
    ${StrStrI} $0 ${Path} '"'
    ${If} $0 != ""
      IntOp $CheckPathSymbolTempVariable ${CHECKPATHSYMBOL_SPECIAL_CHAR} + 0
    ${EndIf}
  ${EndIf}

  ;检测路径中是否包含"<"
  ${If} $CheckPathSymbolTempVariable == ${CHECKPATHSYMBOL_OK}
    ${StrStrI} $0 ${Path} "<"
    ${If} $0 != ""
      IntOp $CheckPathSymbolTempVariable ${CHECKPATHSYMBOL_SPECIAL_CHAR} + 0
    ${EndIf}
  ${EndIf}

  ;检测路径中是否包含">"
  ${If} $CheckPathSymbolTempVariable == ${CHECKPATHSYMBOL_OK}
    ${StrStrI} $0 ${Path} ">"
    ${If} $0 != ""
      IntOp $CheckPathSymbolTempVariable ${CHECKPATHSYMBOL_SPECIAL_CHAR} + 0
    ${EndIf}
  ${EndIf}

  ;检测路径中是否包含"|"
  ${If} $CheckPathSymbolTempVariable == ${CHECKPATHSYMBOL_OK}
    ${StrStrI} $0 ${Path} "|"
    ;MessageBox MB_OK "Debug:StrStrI | :$0"
    ${If} $0 != ""
      IntOp $CheckPathSymbolTempVariable ${CHECKPATHSYMBOL_SPECIAL_CHAR} + 0
    ${EndIf}
  ${EndIf}   

  ;Restore register values from the stack
  Call PopAllGlobalVariable
  IntOp ${Result} $CheckPathSymbolTempVariable + 0  

  ;MessageBox MB_OK "$Debug:CheckPathSymbolTempVariable"
!macroend
###############################################################

###############################################################
/** 
@param in:sizeIn,传入的大小为M的值
@param out:textSizeOut,输出的的Text值
*/
!macro GetSizeTextByMByte sizeIn textSizeOut
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ${if} ${sizeIn} L> 1024
    IntOp $0 ${sizeIn} / 1024 
    IntOP $1 ${sizeIn} % 1024 
    IntOp $2 $1 * 1000
    IntOp $3 $2 / 1024 
    StrCpy $GetSizeTextTempVariable "$0.$3GB"
  ${Else}
    StrCpy $GetSizeTextTempVariable "${sizeIn}MB"
  ${EndIf}

  ;Restore register values from the stack
  Call PopAllGlobalVariable

  StrCpy ${textSizeOut} $GetSizeTextTempVariable
!macroend
###############################################################

###############################################################
!macro MsgBox text title flags
  StrCpy $0 "${text}"
  StrCpy $1 "${title}"
  IntOp $2 ${flags} + 0
  System::Call "user32::MessageBox(i $HWNDPARENT, t r0, t r1, i r2) i .r9"
!macroend

!macro Tip text title
  !insertmacro MsgBox "${text}" "${title}" 0x40
!macroend
###############################################################

###############################################################
;----------------------------------------------------------------------------
; 本宏定义和函数GetLocalTime是一样的效果，只是函数只能用于安装或是反安装中的一个
; 所以定义这个宏定义可以两边都用
; Superseded by     : GetTime function.
;----------------------------------------------------------------------------
; Title             : Get Local Time
; Short Name        : GetLocalTime
; Last Changed      : 22/Feb/2005
; Code Type         : Function
; Code Sub-Type     : One-way Output
;----------------------------------------------------------------------------
; Required          : System plugin.
; Description       : Gets the current local time of the user's computer
;----------------------------------------------------------------------------
; Function Call     : Call GetLocalTime
;
;                     Pop "$Variable1"
;                       Day.
;
;                     Pop "$Variable2"
;                       Month.
;
;                     Pop "$Variable3"
;                       Year.
;
;                     Pop "$Variable4"
;                       Day of the week name.
;
;                     Pop "$Variable5"
;                       Hour.
;
;                     Pop "$Variable6"
;                       Minute.
;
;                     Pop "$Variable7"
;                       Second.
;----------------------------------------------------------------------------
; Author            : Diego Pedroso
; Author Reg. Name  : deguix
;---------------------------------------------------------------------------- 
!macro GetLocalTimeMacro 
  # Prepare variables
  Push $0
  Push $1
  Push $2
  Push $3
  Push $4
  Push $5
  Push $6
 
  # Call GetLocalTime API from Kernel32.dll
  System::Call '*(&i2, &i2, &i2, &i2, &i2, &i2, &i2, &i2) i .r0'
  System::Call 'kernel32::GetLocalTime(i) i(r0)'
  System::Call '*$0(&i2, &i2, &i2, &i2, &i2, &i2, &i2, &i2)i \
  (.r4, .r5, .r3, .r6, .r2, .r1, .r0,)'
 
  # Day of week: convert to name
  StrCmp $3 0 0 +3
    StrCpy $3 Sunday
      Goto WeekNameEnd
  StrCmp $3 1 0 +3
    StrCpy $3 Monday
      Goto WeekNameEnd
  StrCmp $3 2 0 +3
    StrCpy $3 Tuesday
      Goto WeekNameEnd
  StrCmp $3 3 0 +3
    StrCpy $3 Wednesday
      Goto WeekNameEnd
  StrCmp $3 4 0 +3
    StrCpy $3 Thursday
      Goto WeekNameEnd
  StrCmp $3 5 0 +3
    StrCpy $3 Friday
      Goto WeekNameEnd
  StrCmp $3 6 0 +2
    StrCpy $3 Saturday
  WeekNameEnd:
 
  # Minute: convert to 2 digits format
  IntCmp $1 9 0 0 +2
    StrCpy $1 '0$1'
 
  # Second: convert to 2 digits format
  IntCmp $0 9 0 0 +2
    StrCpy $0 '0$0'
 
  # Return to user
  Exch $6
  Exch
  Exch $5
  Exch
  Exch 2
  Exch $4
  Exch 2
  Exch 3
  Exch $3
  Exch 3
  Exch 4
  Exch $2
  Exch 4
  Exch 5
  Exch $1
  Exch 5
  Exch 6
  Exch $0
  Exch 6 
!macroend
###############################################################

###############################################################
/** 删除Dll等库
这里会进行改名、删除等操作
@param dllName:原来的dll文件名
@param dllReName:若删除不了则进行改名,改名后的dll文件名 
*/
!macro RemoveDll dllName dllReName
  Delete  "${dllName}"  
  Delete  "${dllReName}"
  Rename  "${dllName}" "${dllReName}"
  Delete  "${dllReName}"
!macroend
###############################################################

###############################################################
/** 卸载Dll等库
这里会进行反注册、改名、删除等操作
@param dllName:原来的dll文件名
@param dllReName:若删除不了则进行改名,改名后的dll文件名 
*/
!macro UninstallAndRemoveDll dllName dllReName
  UnRegDll "${dllName}"
  !insertmacro  RemoveDll ${dllName} ${dllReName}  
!macroend

; 卸载Dll等库
!define LIBRARY_COM
!define LIBRARY_SHELL_EXTENSION
!macro UninstallLibrary
  ; 反注册RBShell.dll控件
  !insertmacro UnInstallLib REGDLL SHARED NOREBOOT_NOTPROTECTED "$INSTDIR\RBShell.dll" 
  !insertmacro UnInstallLib DLL NOTSHARED NOREBOOT_NOTPROTECTED "$INSTDIR\msvcr90.dll"
  !insertmacro UnInstallLib DLL NOTSHARED NOREBOOT_NOTPROTECTED "$INSTDIR\msvcp90.dll" 
  !insertmacro UnInstallLib DLL NOTSHARED NOREBOOT_NOTPROTECTED "$INSTDIR\Microsoft.VC90.CRT\msvcr90.dll"
  !insertmacro UnInstallLib DLL NOTSHARED NOREBOOT_NOTPROTECTED "$INSTDIR\Microsoft.VC90.CRT\msvcp90.dll"
  !insertmacro UnInstallLib DLL NOTSHARED NOREBOOT_NOTPROTECTED "$INSTDIR\Microsoft.VC90.MFC\mfc90u.dll"	

  !insertmacro GetLocalTimeMacro
  ; $0="01"      day
  ; $1="04"      month
  ; $2="2005"    year
  ; $3="Friday"  day of week name
  ; $4="16"      hour
  ; $5="05"      minute
  ; $6="50"      seconds
  Pop $0
  Pop $1
  Pop $2
  Pop $3
  Pop $4
  Pop $5
  Pop $6

  ; 若RBShell.dll存在则进行改名或删除
  ;MessageBox MB_OK "Debug:$INSTDIR\RBShell($2$1$0$4$5$6).dll"
  ;MessageBox MB_OK 'Debug:Date=$0/$1/$2 ($3)$\nTime=$4:$5:$6'
  !insertmacro UninstallAndRemoveDll "$INSTDIR\RBShell.dll" "$INSTDIR\RBShell($2$1$0$4$5$6).dll"
  !insertmacro RemoveDll "$INSTDIR\msvcr90.dll" "$INSTDIR\msvcr90($2$1$0$4$5$6).dll"
  !insertmacro RemoveDll "$INSTDIR\msvcp90.dll" "$INSTDIR\msvcp90($2$1$0$4$5$6).dll"
  !insertmacro RemoveDll "$INSTDIR\Microsoft.VC90.CRT\msvcr90.dll" "$INSTDIR\Microsoft.VC90.CRT\msvcr90($2$1$0$4$5$6).dll"
  !insertmacro RemoveDll "$INSTDIR\Microsoft.VC90.CRT\msvcp90.dll" "$INSTDIR\Microsoft.VC90.CRT\msvcp90($2$1$0$4$5$6).dll" 
  !insertmacro RemoveDll "$INSTDIR\Microsoft.VC90.MFC\mfc90u.dll" "$INSTDIR\Microsoft.VC90.MFC\mfc90u($2$1$0$4$5$6).dll" 

!macroend
###############################################################

###############################################################
;刷新桌面;
!macro RefreshDesktop
  StrCpy $6 "Progman"
  StrCpy $7 "Program Manager"
  StrCpy $8 "SHELLDLL_DefView"
  StrCpy $9 "SysListView32"
  System::Call "user32.dll::GetDesktopWindow() i .r3"
  System::Call "user32.dll::FindWindowEx(i r3, i 0, t r6, t r7) i .r3"
  System::Call "user32.dll::FindWindowEx(i r3, i 0, t r8, i 0) i .r3"
  System::Call "user32.dll::FindWindowEx(i r3, i 0, t r9, i 0) i .r3"
  System::Call "user32.dll::PostMessage(i r3, i 0x0100, i 0x74, i 0)"
  System::Call "user32.dll::PostMessage(i r3, i 0x0101, i 0x74, i 0x80000000)"
  System::Call 'Shell32::SHChangeNotify(i 0x8000000, i 0, i 0, i 0)'
!macroend
###############################################################

###############################################################
/* 判断dll或exe文件是否被使用
@return $9  1 -> 正在被使用
  $9  0 -> 不在被使用
*/
!macro IsBinaryFileInUse FilePath
    IntOp $9 0 + 0    ;return var

  StrCpy $0 ${FilePath}
    IfFileExists $0 0 done_IsBinaryFileInUse
    System::Call "Kernel32::CreateFile(t r0, i 1073741824, i 0, i 0, i 3, i 128, i 0) i .r1"

   IntCmp $1 -1 0 +3 +3
   IntOp $9 0 + 1
    Goto done_IsBinaryFileInUse
    System::Call "Kernel32::CloseHandle(i r1)"
  
done_IsBinaryFileInUse:
!macroend
###############################################################

###############################################################
/* 检查Rainbow是否正在运行
@return $9  1 -> 正在运行
        $9  0 -> 不在运行
*/
!macro IsEverFavRunning
  IntOp $9 0 + 0    ;return var
  ReadRegStr $0 ${PRODUCT_INST_ROOT_KEY} "${PRODUCT_INST_KEY}" "Install"
  StrCpy $0 "$0\EverFav.exe"
  
  ${If} ${FileExists} $0
    System::Call "Kernel32::CreateFile(t r0, i 1073741824, i 0, i 0, i 3, i 128, i 0) i .r1"
    ${If} $1 == -1
      ;FindWindow $0 "" ${CORE_WINDOW_TITLE}
      FindWindow $0 "" ${PRODUCT_WINDOW_TITLE}  
      IsWindow $0 0 done_CheckIfRunning
      IntOp $9 1 + 0
    ${Else}
      System::Call "Kernel32::CloseHandle(i r1)"
    ${EndIf}    
  ${EndIf}
  done_CheckIfRunning:
!macroend
###############################################################

###############################################################
!macro IsUpdateRunning
  IntOp $9 0 + 0  ;retval
  
  ReadRegStr $0 ${PRODUCT_INST_ROOT_KEY} "${PRODUCT_INST_KEY}" "Install"
  StrCpy $0 "$0\UTUpdate.exe"
  IfFileExists $0 0 done_CheckIfUpdateRunning
  System::Call "Kernel32::CreateFile(t r0, i 1073741824, i 0, i 0, i 3, i 128, i 0) i .r1"
  IntCmp $1 -1 +3 0
  System::Call "Kernel32::CloseHandle(i r1)"
  Goto done_CheckIfUpdateRunning
  FindWindow $0 "" ${UPDATE_WINDOW_TITLE}
  IsWindow $0 0 +2
  IntOp $9 1 + 0
  done_CheckIfUpdateRunning:

!macroend
###############################################################

###############################################################
/* 获得控件相对于父窗口的区域信息
@param hwndParent
@param dlgItemId
@return $0 x
@return $1 y
@return $2 width
@return $3 height
*/
;下面为本函数中要用到的全局变量
Var getDlgItemRect_X
Var getDlgItemRect_Y
Var getDlgItemRect_Width
Var getDlgItemRect_Height
!macro GetDlgItemRect hwndParent hwndCtrl
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ;先将父窗口句柄存起来,$8
  IntOp $8 ${hwndParent} + 0
  ;获取相应控件的句柄,$9
  IntOp $9 ${hwndCtrl} + 0

  ; Reposition window in the lower left
  ; Create RECT struct,$7
  System::Call "*${stRECT} .r7"
  ; Find Window info for the window we're displaying
  System::Call "user32::GetWindowRect(i r9, i r7) i .r6"

  ; Get left/top/right/bottom
  System::Call "*$7${stRECT} (.r0, .r1, .r2, .r3)"
  ; 这里先存起来获得的高度和宽度放入$2和$3中
  ; Calculate width/height of our window,
  IntOp $2 $2 - $0 ; $2 now contains the width
  IntOp $3 $3 - $1 ; $3 now contains the height

  System::Call "user32::ScreenToClient(i r8, i r7) i .r6"
  ;将x，y坐标存起来,$0,$1
  System::Call "*$7${stRECT} (.r0, .r1, , )"
  
  ;现存起来要设置的返回值，恢复堆栈时会破坏掉
  IntOp $getDlgItemRect_X $0  + 0 ; $0 now contains the x
  IntOp $getDlgItemRect_Y $1  + 0 ; $0 now contains the y
  IntOp $getDlgItemRect_Width $2  + 0 ; $0 now contains the width
  IntOp $getDlgItemRect_Height $3  + 0 ; $0 now contains the height

  ;MessageBox MB_OK "Debug:GetDlgItemRect X:$getDlgItemRect_X,Y:$getDlgItemRect_Y,width:$getDlgItemRect_Width, height:$getDlgItemRect_Height"

  ;Restore register values from the stack
  Call PopAllGlobalVariable
  
  ;堆栈恢复后，设置返回值
  IntOp $0 $getDlgItemRect_X + 0 ; $0 now contains the x
  IntOp $1 $getDlgItemRect_Y + 0 ; $0 now contains the y
  IntOp $2 $getDlgItemRect_Width + 0 ; $0 now contains the width
  IntOp $3 $getDlgItemRect_Height + 0 ; $0 now contains the height

  ;MessageBox MB_OK "Debug:GetDlgItemRect x:$0,Y:$1,width:$2, height:$3"
!macroend
###############################################################

###############################################################
/* 获得控件相对于父窗口的区域信息
@param hwndParent
@param hwndCtrl
@param widthCtrl
@param heightCtrl
@return void
*/
!macro ChangeCtrlSize hwndParent hwndCtrl widthCtrl heightCtrl
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ;MessageBox MB_OK "Debug:ChangeCtrlSize hwndParent:${hwndParent} hwndCtrl:${hwndCtrl} widthCtrl:${widthCtrl} heightCtrl:${heightCtrl}"
  
  /**先将传入的参数存储起来
  防止传入的为$1等变量时，被下面的代码覆盖掉
  */
  ;先将父窗口句柄存起来,$8
  IntOp $8 ${hwndParent} + 0
  ;获取相应控件的句柄,$9
  IntOp $9 ${hwndCtrl} + 0
  ;宽度
  IntOp $6 ${widthCtrl} + 0
  ;高度
  IntOp $7 ${heightCtrl} + 0

  ;GetDlgItemRect宏定义返回值：@return $0 x, @return $1 y, @return $2width,  @return $3 height,
  !insertmacro GetDlgItemRect $8 $9

  ;宽度
  IntOp $2 $6 + 0
  ;高度
  IntOp $3 $7  + 0
  
  ;MessageBox MB_OK "Debug:ChangeCtrlSize x:$0,Y:$1,width:$2, height:$3"   
  System::Call "User32::SetWindowPos(i, i, i, i, i, i, i) b (r9, 0, r0, r1, r2, r3, ${SWP_NOMOVE})"

  ;Restore register values from the stack
  Call PopAllGlobalVariable
!macroend
###############################################################

###############################################################
/* 获得控件相对于父窗口的区域信息
@param hwndParent
@param hwndCtrl
@param xPosCtrl
@param yPosCtrl
@return void
*/
!macro MoveCtrl hwndParent hwndCtrl xPosCtrl yPosCtrl
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ;MessageBox MB_OK  "Debug:MoveCtrl hwndParent:${hwndParent} hwndCtrl:${hwndCtrl} xPosCtrl:${xPosCtrl} yPosCtrl:${yPosCtrl}"

  /**先将传入的参数存储起来
  防止传入的为$1等变量时，被下面的代码覆盖掉
  */
  ;先将父窗口句柄存起来,$8
  IntOp $8 ${hwndParent} + 0
  ;获取相应控件的句柄,$9
  IntOp $9 ${hwndCtrl} + 0
  ;x
  IntOp $6 ${xPosCtrl} + 0
  ;y
  IntOp $7 ${yPosCtrl} + 0

  ;GetDlgItemRect宏定义返回值：@return $0 x, @return $1 y, @return $2width,  @return $3 height,
  !insertmacro GetDlgItemRect $8 $9
  ;x
  IntOp $0 $6 + 0
  ;y
  IntOp $1 $7 + 0

  ;MessageBox MB_OK "Debug:MoveCtrl hwndParent:${hwndParent} hwndCtrl:${hwndCtrl} xPosCtrl:$0 yPosCtrl:$1"  
  ;MessageBox MB_OK "Debug:x:$0,Y:$1,width:$2, height:$3"   
  System::Call "User32::SetWindowPos(i, i, i, i, i, i, i) b (r9, 0, r0, r1, r2, r3, ${SWP_NOSIZE})"

  ;Restore register values from the stack
  Call PopAllGlobalVariable
!macroend
###############################################################

###############################################################
/* 拷贝系统CRT 相关dll到目录中
@param DstPath:拷贝的目的路径
@return void.
*/
!macro CopySystemCRTDll2Dir DstPath
  ;首先创建目录可能目录会不存在
  CreateDirectory ${DstPath}
  ;拷贝系统dll
  CopyFiles /SILENT $INSTDIR\Microsoft.VC90.CRT\*.* ${DstPath}
!macroend
###############################################################

###############################################################
/* 拷贝系统MFC 相关dll到目录中
@param DstPath:拷贝的目的路径
@return void.
*/
!macro CopySystemMFCDll2Dir DstPath
  ;首先创建目录可能目录会不存在
  CreateDirectory ${DstPath}
  ;拷贝系统dll
  CopyFiles /SILENT $INSTDIR\Microsoft.V90.MFC\*.* ${DstPath}
!macroend
###############################################################

###############################################################
/* 拷贝系统MFCLOC 相关dll到目录中
@param DstPath:拷贝的目的路径
@return void.
*/
!macro CopySystemMFCLOCDll2Dir DstPath
  ;首先创建目录可能目录会不存在
  CreateDirectory ${DstPath}
  ;拷贝系统dll
  CopyFiles /SILENT $INSTDIR\Microsoft.VC90.MFCLOC\*.*  ${DstPath}
!macroend
###############################################################

###############################################################
/* 拷贝系统ATL 相关dll到目录中
@param DstPath:拷贝的目的路径
@return void.
*/
!macro CopySystemATLDll2Dir DstPath
  ;首先创建目录可能目录会不存在
  CreateDirectory ${DstPath}
  ;拷贝系统dll
  CopyFiles /SILENT $INSTDIR\Microsoft.VC90.ATL\*.*  ${DstPath}
!macroend
###############################################################

###############################################################
/* 拷贝系统dll到目录中
@param DstPath:拷贝的目的路径
@return void.
*/
!macro CopySystemDll2Dir DstPath
  ;首先创建目录可能目录会不存在
  CreateDirectory ${DstPath}
  ;拷贝系统dll
  !insertmacro CopySystemCRTDll2Dir ${DstPath}
  !insertmacro CopySystemMFCDll2Dir ${DstPath}
  !insertmacro CopySystemMFCLOCDll2Dir ${DstPath}
  !insertmacro CopySystemATLDll2Dir ${DstPath}  
!macroend
###############################################################

###############################################################
/* 删除快捷方式
@param ShortcutName:快捷方式的名字
@return void.
*/
!macro RemoveShortcut ShortcutName
  Delete "$QUICKLAUNCH\${ShortcutName}.lnk"
  Delete "$DESKTOP\${ShortcutName}.lnk"
  Delete "$SMSTARTUP\${ShortcutName}.lnk"
  Delete "$SMPROGRAMS\EverFav\${ShortcutName}.lnk"
  RMDir "$SMPROGRAMS\EverFav"
!macroend
###############################################################

###############################################################
/* 创建快捷方式
@param ShortcutName:快捷方式的名字
@return void.
*/
!macro CreateShortcut ShortcutName  
  CreateDirectory "$SMPROGRAMS\EverFav"
  CreateShortCut "$SMPROGRAMS\EverFav\${ShortcutName}.lnk" "$INSTDIR\EverFav.exe"
  CreateShortCut "$DESKTOP\${ShortcutName}.lnk" "$INSTDIR\EverFav.exe"
  CreateShortCut "$QUICKLAUNCH\${ShortcutName}.lnk" "$INSTDIR\EverFav.exe"
  CreateShortCut "$SMSTARTUP\${ShortcutName}.lnk" "$INSTDIR\EverFav.exe"
!macroend
###############################################################

###############################################################
/***********************************Section代码********************************/
Section "MainSection" MainSectionId

  ;Call GetPhotoUploaderDir

  ;拷贝系统dll到安装目录下
  Call CopySystemDll2InstallDir
  
  SetOutPath "$INSTDIR"
  
  SetOverwrite on
  File /r /x Microsoft.VC90.ATL /x Microsoft.VC90.CRT /x Microsoft.VC90.MFC /x Microsoft.VC90.MFCLOC "${SRC_DIR}\*.*"

  /**
  File "${SRC_DIR}\RainBowInstallHelper.dll"

  StrCpy $1 "RBEmotionAdderOCX.ocx"
  ;MessageBox MB_OK "Debug: StrCpy $$1 $$INSTDIR:$1"
  System::Call "RainBowInstallHelper::InstallHelper(t r1) i .r7"
  ${If} $7 == 1   
    quit
  ${EndIf}

  StrCpy $1 "MusicX.ocx"
  ;MessageBox MB_OK "Debug: StrCpy $$1 $$INSTDIR:$1"
  System::Call "RainBowInstallHelper::InstallHelper(t r1) i .r8"
  ${If} $8 == 1   
    quit
  ${EndIf}

  StrCpy $1 "rainbowweb2.dll"
  ;MessageBox MB_OK "Debug: StrCpy $$1 $$INSTDIR:$1"
  System::Call "RainBowInstallHelper::InstallHelper(t r1) i .r9"

  ${If} $9 == 1   
    quit
  ${EndIf}
  
  SetOverwrite on
  File /r /x msvcr71.dll /x rainbowweb.dll /x photouploader /x RainBowInstallHelper.dll /x RBEmotionAdderOCX.ocx /x MusicX.ocx /x rainbowweb2.dll /x ShiftPersonalData.exe /x Microsoft.vc90.MFCLOC /x Microsoft.vc90.MFC /x Microsoft.vc90.CRT "${SRC_DIR}\*.*"
  SetOverwrite try
  */
  /**
  ${If} $7 == 0   
    File "${SRC_DIR}\RBEmotionAdderOCX.ocx"
  ${EndIf}
  
  ${If} $8 == 0   
    File "${SRC_DIR}\MusicX.ocx"
  ${EndIf}
  
  ${If} $9 == 0   
    File "${SRC_DIR}\rainbowweb2.dll"
  ${EndIf}
  */
  /*    注释 2008.09.22 温辉敏
  File "${SRC_DIR}\msvcr71.dll"
  File "${SRC_DIR}\rainbowweb.dll"
  */
  ;File "${SRC_DIR}\rainbowweb.dll"
  /**
  File "${SRC_DIR}\rainbowweb2.dll"

  !insertmacro IsBinaryFileInUse "$INSTDIR\rainbowweb.dll"
  ;IntCmp $9 1 0 +3 +3
  ${If} $9 == 1    
  File /oname=rainbowweb2.dll "${SRC_DIR}\rainbowweb2.dll"
    IntOp $IsRainbowWebDllInUse 1 + 0
  ${EndIf}
  */
  /* 注释 2008.09.22 温辉敏  
  SetOutPath $InstallDirForPhotoUploader
  File /r "${SRC_DIR}\PhotoUploader\*.*"
  */
  SetShellVarContext all
  ;删除下面不带51挂挂的链接,防止有多个链接
  /**
  !insertmacro RemoveShortcut 彩虹2009
  !insertmacro RemoveShortcut 彩虹2009(原51挂挂)
  !insertmacro RemoveShortcut 彩虹2009(公测版)
  !insertmacro RemoveShortcut 彩虹(原51挂挂)
  !insertmacro RemoveShortcut 彩虹
   */ 
  !insertmacro CreateShortcut EverFav
    
  !insertmacro RefreshDesktop
SectionEnd

Section -AdditionalIcons
  WriteIniStr "$INSTDIR\${PRODUCT_NAME}.url" "InternetShortcut" "URL" "${PRODUCT_WEB_SITE}"
  SetShellVarContext all
  
  /**
  现改用在开始菜单中不放彩虹主页.lnk(有些机器上不能显示正确的图标)，
  现直接放彩虹主页.url，所以安装时删除以前的彩虹主页.lnk
  */
  Delete "$SMPROGRAMS\EverFav\EverFav主页.lnk"
  WriteIniStr "$SMPROGRAMS\EverFav\EverFav主页.url" "InternetShortcut" "URL" "${PRODUCT_WEB_SITE}"
  ;CreateShortCut "$SMPROGRAMS\彩虹\彩虹主页.lnk" "$INSTDIR\${PRODUCT_NAME}.url"
  CreateShortCut "$SMPROGRAMS\EverFav\卸载EverFav.lnk" "$INSTDIR\uninst.exe"
SectionEnd

Section -Post  
  ; 注册卸载信息,以便在控制面板中可以卸载
  WriteUninstaller "$INSTDIR\uninst.exe"
  WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} "${PRODUCT_UNINST_KEY}" "DisplayName" "$(^Name)"
  WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} "${PRODUCT_UNINST_KEY}" "UninstallString" "$INSTDIR\uninst.exe"
  WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} "${PRODUCT_UNINST_KEY}" "DisplayVersion" "${PRODUCT_VERSION}"
  WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} "${PRODUCT_UNINST_KEY}" "URLInfoAbout" "${PRODUCT_WEB_SITE}"
  WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} "${PRODUCT_UNINST_KEY}" "Publisher" "${PRODUCT_PUBLISHER}"
SectionEnd

Section Uninstall

  ; 反注册com组件dll
  SetOutPath $INSTDIR
  /**
  UnRegDll $INSTDIR\rainbowweb.dll

  ; 反注册MusicX.ocx控件
  UnRegDll $INSTDIR\MusicX.ocx

  ; 反注册RBShell.dll控件
  UnRegDll $INSTDIR\RBShell.dll
  */
  ; Delete file/dir
  Delete "$INSTDIR\${PRODUCT_NAME}.url"
  Delete "$INSTDIR\uninst.exe"
  
  ;调用卸载统计
  StrCpy $0 $INSTDIR
  System::Call "gt::gt(i 0, t r0) ? u"
  
  SetShellVarContext all
  
  Delete "$SMPROGRAMS\EverFav\卸载EverFav.lnk"
  Delete "$SMPROGRAMS\EverFav\EverFav主页.lnk"
  Delete "$SMPROGRAMS\EverFav\EverFav主页.url"
/**
  !insertmacro RemoveShortcut 彩虹2009
  !insertmacro RemoveShortcut 彩虹2009(原51挂挂)
  !insertmacro RemoveShortcut 彩虹2009(公测版)
  !insertmacro RemoveShortcut 彩虹(原51挂挂)
*/
  !insertmacro RemoveShortcut EverFav
  /**
  RMDir /r "$INSTDIR\sound"
  RMDir /r "$INSTDIR\Skin"
  RMDir /r "$INSTDIR\face"
  RMDir /r "$INSTDIR\config"
  RMDir /r "$INSTDIR\ChatEmotion"
  */
  RMDir /r "$INSTDIR\Microsoft.VC90.CRT"
  RMDir /r "$INSTDIR\Microsoft.VC90.MFC"
  RMDir /r "$INSTDIR\Microsoft.VC90.MFCLOC"
  RMDir /r "$INSTDIR\PlugIn"
  RMDir /r "$INSTDIR\Skin"
  
  Delete "$INSTDIR\*.*"  
  ;Rename  "$INSTDIR\gt.dll" "$INSTDIR\gt_dll"
  Delete  "$INSTDIR\*.dll"
  ;Rename  "$INSTDIR\gt_dll" "$INSTDIR\gt.dll"
  Delete  "$INSTDIR\*.exe"
  ;Delete  "$INSTDIR\Features.txt"
  Delete  "$INSTDIR\License.txt"
  ;Delete  "$INSTDIR\Rainbow.dat"
  Delete  "$INSTDIR\*.manifest"
  ;Delete  "$INSTDIR\*.ocx"
  
  
 !insertmacro UninstallLibrary
   
  DeleteRegKey ${PRODUCT_UNINST_ROOT_KEY} "${PRODUCT_UNINST_KEY}"

  ; 删除版本，安装路径等
  DeleteRegKey ${PRODUCT_INST_ROOT_KEY} "${PRODUCT_INST_KEY}"
  DeleteRegKey HKCU "${PRODUCT_INST_KEY}"
  DeleteRegKey HKCU "Software\Classes\VirtualStore\MACHINE\SOFTWARE\3+Corp\EverFav"    ; for vista

  ; 删除开机自启动Rainbow
  DeleteRegValue HKLM "SOFTWARE\Microsoft\Windows\CurrentVersion\Run" "EverFav"

  !insertmacro RefreshDesktop   ;刷新桌面后,图标才会消失(vista)  
  SetAutoClose true
SectionEnd

/****************************************************下面为NSIS安装函数*********************************************************/
/* 获得系统版本号
@return $4 主版本号
@return $5 次版本号
*/
Function GetOsVersion
  System::Call "kernel32.dll::GetVersion() i .r0"
  IntOp $4 $0 & 0xFF    ;main ver
  IntOp $5 $0 & 0xFF00    ;sub ver
  IntOp $5 $5 >> 8
  
  Push $5
  Push $4
FunctionEnd


/* 获得主次版本号
@param $0 版本信息，形如"3.1.0.270",且主次版本号最多为99(如:"99.99.0.270")
@return $4 sub ver,int
@return $3 main ver,int
@return $5 ver(=main*100+sub),int
*/
Function GetVer
  Pop $0                ;ver info
  
  IntOp $8 0 + 0        ;index
  StrCpy $1 $0 1 $8        ;main ver var
  IntOp $8 $8 + 1
  StrCpy $7 $0 1 $8      ;temp var
  IntOp $8 $8 + 1
  StrCmp $7 "." +3 0
  StrCpy $1 "$1$7"
  IntOp $8 $8 + 1
  StrCpy $2 $0 1 $8       ;sub ver var
  IntOp $8 $8 + 1
  StrCpy $7 $0 1 $8
  IntOp $8 $8 + 1
  StrCmp $7 "." +2 0
  StrCpy $2 "$2$7"
  ;IntOp $8 $8 + 1
  
  System::Call "ntdll.dll::atoi(t r1) i .r3"
  System::Call "ntdll.dll::atoi(t r2) i .r4"
  IntOp $5 $3 * 100
  IntOp $5 $5 + $4
  
  Push $4
  Push $3
  Push $5

FunctionEnd

/**将所有的内置全局变量压入堆栈
$0~$9,$R0~$R9
*/
Function PushAllGlobalVariable
  ;Save existing register values to the stack
  Push $0
  Push $1
  Push $2
  Push $3
  Push $4
  Push $5
  Push $6
  Push $7
  Push $8
  Push $9
  Push $R0
  Push $R1
  Push $R2
  Push $R3
  Push $R4
  Push $R5
  Push $R6
  Push $R7
  Push $R8
  Push $R9
FunctionEnd

/**将所有的内置全局变量从堆栈弹出
$0~$9,$R0~$R9
*/
Function PopAllGlobalVariable
  ;Restore register values from the stack
  Pop $R9
  Pop $R8
  Pop $R7
  Pop $R6
  Pop $R5
  Pop $R4
  Pop $R3
  Pop $R2
  Pop $R1
  Pop $R0
  Pop $9
  Pop $8
  Pop $7
  Pop $6
  Pop $5
  Pop $4
  Pop $3
  Pop $2
  Pop $1
  Pop $0
FunctionEnd

/**修改目录选择页面的代码
在OnDirectoryPageShow中被调用
*/
Var hwndSubWindow
Function ChangeDirectorPageShowUI
  ;Save existing register values to the stack
  Call PushAllGlobalVariable
  
  ;$8保存了子窗口的句柄,并将子窗口句柄存在$hwndSubWindow中
  FindWindow $8 "#32770" "" $HWNDPARENT
  IntOp $hwndSubWindow $8 + 0

  ;减小“安装程序将安装 My application 1.0 在下列文件夹。。。“控件的高度
  ;获取相应控件的句柄,$9
  GetDlgItem $9 $hwndSubWindow 0x3ee
  ;GetDlgItemRect宏定义返回值：@return $0 x, @return $1 y, @return $2width,  @return $3 height,
  !insertmacro GetDlgItemRect $8 $9  
  IntOP $3 $3 - 55
  ;MessageBox MB_OK "Debug:ChangeCtrlSizex:$0,Y:$1,width:$2, height:$3" 
  !insertmacro ChangeCtrlSize $8 $9 $2 $3
  
  ;将“目标文件夹“控件往上移动
  ;获取相应控件的句柄,$9
  GetDlgItem $9 $hwndSubWindow 0x3fc
  !insertmacro GetDlgItemRect $8 $9
  IntOP $1 $1 - 70
  !insertmacro MoveCtrl $8 $9 $0 $1
  
  ;修改“目标文件夹”为“程序安装目录”
  StrCpy $1 "程序安装目录"
  System::Call "user32::SetWindowText(i r9, t r1)"
    
  ;将“目录选择结果显示框“控件往上移动
  ;获取相应控件的句柄,$9
  GetDlgItem $9 $hwndSubWindow 0x3fb
  !insertmacro GetDlgItemRect $8 $9
  IntOP $1 $1 - 70
  !insertmacro MoveCtrl $8 $9 $0 $1

  ;将“目录选择按钮“控件往上移动
  ;获取相应控件的句柄,$9
  GetDlgItem $9 $hwndSubWindow 0x3e9
  !insertmacro GetDlgItemRect $8 $9
  IntOP $1 $1 - 70
  !insertmacro MoveCtrl $8 $9 $0 $1
  
  ;将“显示剩余空间“控件往上移动
  ;获取相应控件的句柄,$9
  GetDlgItem $9 $hwndSubWindow 0x3ff
  !insertmacro GetDlgItemRect $8 $9
  IntOP $1 $1 - 77
  !insertmacro MoveCtrl $8 $9 $0 $1
  
  ;将“所需空间“控件往上移动
  ;获取相应控件的句柄,$9
  GetDlgItem $9 $hwndSubWindow 0x400
  !insertmacro GetDlgItemRect $8 $9
  IntOP $1 $1 - 77
  !insertmacro MoveCtrl $8 $9 $0 $1

  ; 创建选择个人文件夹的GroupBox
  ;StrCpy $0 "#32770"
  ;System::Call "user32::FindWindowEx(i $HWNDPARENT, i 0, t r0, t) i .r3"
  ;将子窗口句柄存入$3中
  IntOp $3 $hwndSubWindow + 0
  StrCpy $0 "BUTTON"
  StrCpy $1 "个人文件夹"
  System::Call "user32::CreateWindowEx(i 0, t r0, t r1, i 0x50000007, i 0, i 130, i 450, i 80, i r3, i 12343, i 0, i 0) i .r5"
  
  SetCtlColors $5 "" transparent
  ;MessageBox  MB_OK "Debug:${MUI_BGCOLOR}"
  ;SetCtlColors $5 "" "/grey"
  ;MessageBox  MB_OK "Debug:${MUI_LICENSEPAGE_BGCOLOR}"
  ;System::Call "user32::SetWindowText(i r5, t r1)"
  
  ;设置控件的字体
  CreateFont $0 "宋体" 9
  SendMessage $5 ${WM_SETFONT} $0 1
  ;ShowWindow $5 ${SW_HIDE}

  System::Call "user32::GetSysColor()"

  ; 创建"选择个人文件夹（用于保存消息记录等数据）的保存位置"的文本提示框
  ;StrCpy $0 "#32770"
  ;System::Call "user32::FindWindowEx(i $HWNDPARENT, i 0, t r0, t) i .r3"
  ;将子窗口句柄存入$3中
  ;IntOp $3 $hwndSubWindow + 0
  StrCpy $0 "STATIC"
  StrCpy $1 "选择个人文件夹(用于保存消息记录等数据)的保存位置"
  System::Call "user32::CreateWindowEx(i 0, t r0, t r1, i 0x50000000, i 20, i 148, i 400, i 15, i r3, i 12344, i 0, i 0) i .r5"
  ;SetCtlColors $5 0x0 0x00ECE9D8
  SetCtlColors $5 "" transparent
  CreateFont $0 "宋体" 9
  SendMessage $5 ${WM_SETFONT} $0 1

  ; 创建选择个人文件夹的两个RadioButton
  ;StrCpy $0 "#32770"
  ;System::Call "user32::FindWindowEx(i $HWNDPARENT, i 0, t r0, t) i .r3"
  ;将子窗口句柄存入$3中
  ;IntOp $3 $hwndSubWindow + 0
  StrCpy $0 "BUTTON"

  ${If} ${AtLeastWinVista}
    StrCpy $1 "保存到安装目录下(Vista或更高版本的系统不支持此选项)"
    ;MessageBox MB_OK "Debug:Vista"
  ${Else}
    StrCpy $1 "保存到安装目录下"
    ;MessageBox MB_OK "Debug:非Vista"
  ${EndIf}

  System::Call "user32::CreateWindowEx(i 0, t r0, t r1, i 0x50000009, i 20, i 165, i 400, i 20, i r3, i 12345, i 0, i 0) i .r5"
  ;System::Call "user32::CheckDlgButton(i r3, i 12345, i 1)"
  ;SetCtlColors $5 0x0 0x00ECE9D8
  SetCtlColors $5 "" transparent
  CreateFont $0 "宋体" 9
  SendMessage $5 ${WM_SETFONT} $0 1
  ;ShowWindow $5 ${SW_HIDE}
  
  ;StrCpy $0 "#32770"
  ;System::Call "user32::FindWindowEx(i $HWNDPARENT, i 0, t r0, t) i .r3"
  ;将子窗口句柄存入$3中
  ;IntOp $3 $hwndSubWindow + 0
  StrCpy $0 "BUTTON"
  StrCpy $1 "保存到$\"我的文档$\"(推荐)"
  System::Call "user32::CreateWindowEx(i 0, t r0, t r1, i 0x50000009, i 20, i 185, i 200, i 20, i r3, i 12346, i 0, i 0) i .r5"
  IntOp $RdoBtn_MyDocument_Folder $5 + 0
  ;System::Call "user32::CheckDlgButton(i r3, i 12346, i 1)"
  ;SetCtlColors $5 0x0 0x00ECE9D8
  SetCtlColors $5 "" transparent
  CreateFont $0 "宋体" 9
  SendMessage $5 ${WM_SETFONT} $0 1
  ;ShowWindow $5 ${SW_HIDE}
  
  ;MessageBox MB_OK "Debug :RdoBtn_MyDocument_Folder_State ： $RdoBtn_MyDocument_Folder_State"
  ${If} 1 == $RdoBtn_MyDocument_Folder_State
    System::Call "user32::CheckDlgButton(i r3, i 12346, i 1)"
    ;MessageBox MB_OK "Debug:1"
  ${Else}
    System::Call "user32::CheckDlgButton(i r3, i 12345, i 1)"
    ;MessageBox MB_OK "Debug:0"
  ${EndIf}

  ;若为Vista以上版本则disable掉选择安装目录下的数字文件夹的RadioBtn
  ${If} ${AtLeastWinVista}
    System::Call "user32::CheckDlgButton(i r3, i 12345, i 0)"
    GetDlgItem $0 $3 12345
    EnableWindow $0 0

    System::Call "user32::CheckDlgButton(i r3, i 12346, i 1)"
    ;MessageBox MB_OK "Debug:Vista"
  ${Else}
    ;MessageBox MB_OK "Debug:非Vista"
  ${EndIf}

  ;Restore register values from the stack
  Call PopAllGlobalVariable  
FunctionEnd


/* 拷贝系统dll到安装目录(caihong.exe所在目录中)
@param DstPath:拷贝的目的路径
@return void.
*/

Function CopySystemDll2InstallDir  

  SetOutPath "$INSTDIR\Microsoft.VC90.MFCLOC"
  File "${SRC_DIR}\Microsoft.VC90.MFCLOC\*.*"  

  SetOutPath "$INSTDIR\Microsoft.VC90.MFC"
  File "${SRC_DIR}\Microsoft.VC90.MFC\*.*" 
  
  SetOutPath "$INSTDIR\Microsoft.VC90.CRT"
  File "${SRC_DIR}\Microsoft.VC90.CRT\*.*"

  SetOutPath "$INSTDIR"  

  ;获取操作系统版本
  Call GetWindowsVersion
  Pop $R0
  ;若为Vista操作系统则不用删除MFC等目录，也不用将文件拷贝出来

  ${If} $R0 == 'Vista' 
  ${OrIf} $R0 == 'Win7'
  ${OrIf} $R0 == 'AboveWin7Version'
    ;do nothing
  ${Else}
    ;拷贝系统dll
    CopyFiles /SILENT $INSTDIR\Microsoft.VC90.MFCLOC\*.*  $INSTDIR
    CopyFiles /SILENT $INSTDIR\Microsoft.VC90.MFC\*.*  $INSTDIR
    CopyFiles /SILENT $INSTDIR\Microsoft.VC90.CRT\*.*  $INSTDIR
    CopyFiles /SILENT $INSTDIR\Microsoft.VC90.ATL\*.*  $INSTDIR

    ;删除几个多出来的目录
    RMDir /r  $INSTDIR\Microsoft.VC90.MFCLOC
    RMDir /r  $INSTDIR\Microsoft.VC90.MFC
    RMDir /r  $INSTDIR\Microsoft.VC90.CRT
    RMDir /r  $INSTDIR\Microsoft.VC90.ATL
  ${EndIf}
FunctionEnd

;拷贝系统dll到系统目录下
Function CopySystemDll
  ReadRegStr $0 HKLM "SOFTWARE\Microsoft\Windows NT\CurrentVersion" CurrentVersion
  strcmp $0 "" Win98 WinNT
  Win98:
  MessageBox  MB_ICONINFORMATION|MB_OK|MB_TOPMOST "您使用的操作系统版本过低，无法安装，程序将退出！"
  quit
  WinNT:
  
  ;获取操作系统版本
  Call GetWindowsVersion

  Pop $R0
  StrCmp $R0 "NT 3.0" label_WINNT_X
  StrCmp $R0 "NT 4.0" label_WINNT_X
  StrCmp $R0 '2000' label_WINNT_2000
  StrCmp $R0 'XP' label_WINNT_XP
  StrCmp $R0 '2003' label_WINNT_2003
  StrCmp $R0 'Vista' label_WINNT_VISTA
  StrCmp $R0 'Win7' label_WINNT_WIN7

  label_WINNT_X:
  ;MessageBox  MB_ICONINFORMATION|MB_OK "Debug:label_WINNT_X:！"
  !insertmacro CopySystemDll2Dir $SYSDIR
  Goto label_DONE
  label_WINNT_2000:
  ;MessageBox  MB_ICONINFORMATION|MB_OK "Debug:label_WINNT_2000:！"
  !insertmacro CopySystemDll2Dir $SYSDIR
  Goto label_DONE
  label_WINNT_XP:
  ;MessageBox  MB_ICONINFORMATION|MB_OK "Debug:label_WINNT_XP:！"
  !insertmacro CopySystemCRTDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.crt_1fc8b3b9a1e18e3b_9.0.30729.6161_none_50934f2ebcb7eb57
  !insertmacro CopySystemMFCDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.mfc_1fc8b3b9a1e18e3b_9.0.30729.6161_none_4bf7e3e2bf9ada4c
  !insertmacro CopySystemMFCLOCDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.mfcloc_1fc8b3b9a1e18e3b_9.0.30729.6161_none_49768ef57548175e   
  !insertmacro CopySystemATLDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.atl_1fc8b3b9a1e18e3b_9.0.30729.6161_none_51cd0a7abbe4e19b
  Goto label_DONE
  label_WINNT_2003:
  ;MessageBox  MB_ICONINFORMATION|MB_OK "Debug:label_WINNT_2003:！"
  !insertmacro CopySystemCRTDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.crt_1fc8b3b9a1e18e3b_9.0.30729.6161_none_50934f2ebcb7eb57
  !insertmacro CopySystemMFCDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.mfc_1fc8b3b9a1e18e3b_9.0.30729.6161_none_4bf7e3e2bf9ada4c
  !insertmacro CopySystemMFCLOCDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.mfcloc_1fc8b3b9a1e18e3b_9.0.30729.6161_none_49768ef57548175e   
  !insertmacro CopySystemATLDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.atl_1fc8b3b9a1e18e3b_9.0.30729.6161_none_51cd0a7abbe4e19b
  Goto label_DONE
  label_WINNT_VISTA:
  ;MessageBox  MB_ICONINFORMATION|MB_OK "Debug:label_WINNT_VISTA:！"
  !insertmacro CopySystemCRTDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.crt_1fc8b3b9a1e18e3b_9.0.30729.6161_none_50934f2ebcb7eb57
  !insertmacro CopySystemMFCDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.mfc_1fc8b3b9a1e18e3b_9.0.30729.6161_none_4bf7e3e2bf9ada4c
  !insertmacro CopySystemMFCLOCDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.mfcloc_1fc8b3b9a1e18e3b_9.0.30729.6161_none_49768ef57548175e   
  !insertmacro CopySystemATLDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.atl_1fc8b3b9a1e18e3b_9.0.30729.6161_none_51cd0a7abbe4e19b
  Goto label_DONE
  label_WINNT_WIN7:
  ;MessageBox  MB_ICONINFORMATION|MB_OK "Debug:label_WINNT_WIN7:！"
  !insertmacro CopySystemCRTDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.crt_1fc8b3b9a1e18e3b_9.0.30729.6161_none_50934f2ebcb7eb57
  !insertmacro CopySystemMFCDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.mfc_1fc8b3b9a1e18e3b_9.0.30729.6161_none_4bf7e3e2bf9ada4c
  !insertmacro CopySystemMFCLOCDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.mfcloc_1fc8b3b9a1e18e3b_9.0.30729.6161_none_49768ef57548175e   
  !insertmacro CopySystemATLDll2Dir $WINDIR\winsxs\x86_microsoft.vc90.atl_1fc8b3b9a1e18e3b_9.0.30729.6161_none_51cd0a7abbe4e19b
  Goto label_DONE
  label_DONE:
FunctionEnd


; 安装前检查函数
Function InstallInitCheck
  ;MessageBox MB_OK "Debug: InstallInitCheck"
  ;禁止多个安装实例;
  Call CheckSetupMultiRun

  ;检查管理员权限;
  Call CheckAdminForInstall  
    
CheckEverFavRunning:
  ;MessageBox MB_OK "Debug: CheckRainbowRunning"

  /**
  return on $R0: 
  1 - the process was found 
  0 - the process was not found  
  */
  
  Processes::FindProcess "EverFav.exe"
  ;MessageBox MB_OK "Debug:Processes::FindProcess $R0"
  ${If} $R0 == 1
    ;MessageBox MB_OK "Debug:Processes::FindProcess caihong.exe"
    !insertmacro MsgBox "${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION}正在运行，请先退出，然后重试" "${TITLE}" 0x45
    ${If} $9 == 4
      GoTo CheckEverFavRunning
    ${Else}
      Quit
    ${EndIf}
  ${EndIf}
  
;  !insertmacro IsRainbowRunning
;  IntCmp $9 1 0 done_CheckRainbowRunning done_CheckRainbowRunning
;  !insertmacro MsgBox "${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION}正在运行，请先退出，然后重试" "${TITLE}" 0x45
;  IntCmp $9 4 CheckRainbowRunning 0 0
;  Quit

done_CheckEverFavRunning:
  ;MessageBox MB_OK "Debug: done_CheckRainbowRunning"
  StrCpy $IsInstalledAlready 0  ;默认为没有安装
  ReadRegStr $InstalledPath ${PRODUCT_INST_ROOT_KEY} "${PRODUCT_INST_KEY}" "Install"
  strcpy $InstallToPath $InstalledPath
  StrCmp $InstalledPath "" installpath_no

  ReadRegStr $0 ${PRODUCT_INST_ROOT_KEY} "${PRODUCT_INST_KEY}" "Version"  ; get current version
  Push $0
  Call GetVer
  Pop $R1

  Push ${PRODUCT_VERSION_INFO}
  Call GetVer
  Pop $1
  
  ;MessageBox MB_OK "Debug: $$R1:$R1"
  IntCmp $R1 20 ver_no ver_no 0   ; 0.20版本之前的不置IsInstalledAlready  
  StrCpy $IsInstalledAlready 1  ; 已经安装了Rainbow
  ;MessageBox MB_OK "Debug: IsInstalledAlready:$IsInstalledAlready"
  
  ;MessageBox MB_OK "Debug: $R1:$1"
  ; ver compare
  IntCmp $R1 $1 ver_equal ver_newer ver_older
ver_equal:
  IntOp $RainbowInstallVersionType 0 + 0
  MessageBox MB_YESNO|MB_TOPMOST "这台计算机上已经安装了一个相同的版本,您要继续安装吗" /SD IDYES IDYES do_install
  Abort

ver_newer:
  IntOp $RainbowInstallVersionType 1 + 0
  MessageBox MB_YESNO|MB_TOPMOST "这台计算机上已经安装了一个较老的版本,您要继续安装吗" /SD IDYES IDYES do_install
  Abort

ver_older:
  IntOp $RainbowInstallVersionType -1 + 0
  MessageBox MB_YESNO|MB_TOPMOST "这台计算机上已经安装了一个更高的版本,您要继续安装吗" /SD IDYES IDYES do_install
  Abort

installpath_no:
ver_no:
  IntOp $RainbowInstallVersionType -2 + 0
  ;检测51挂挂是否安装
  ;MessageBox MB_OK "Debug:ver_no"
  ReadRegStr $0 ${PRODUCT_INST_ROOT_KEY} "${PRODUCT_51GG_INST_KEY}" "Version"
  ;MessageBox MB_OK "Debug:51GG Version: $0"
  IntCmp $0 0 do_install do_install 0  
  ; 已经安装了51GG
  StrCpy $IsGGInstalledAlready 1                
  ;MessageBox MB_OK "Debug:IsGGInstalledAlready: $IsGGInstalledAlready"
  ; 读取挂挂安装路径              
  ReadRegStr $GGInstalledPath ${PRODUCT_INST_ROOT_KEY} "${PRODUCT_51GG_INST_KEY}" "Install"  
  ;MessageBox MB_OK "Debug:GGInstalledPath:$GGInstalledPath"

do_install:

CheckUpdateRunning:
  !insertmacro IsUpdateRunning
  IntCmp $9 1 0 done_CheckUpdateRunning
  MessageBox MB_OK|MB_ICONSTOP|MB_TOPMOST "EverFav升级程序正在运行，现在无法进行安装"
  Abort
done_CheckUpdateRunning:
  ;全局变量初始化
  ;初始化个人数据选择文件夹  
  ${If} 1 == $IsInstalledAlready
    ;以前安装过彩虹,get PersonalFolderIsMyDocument    
    ReadRegStr $RdoBtn_MyDocument_Folder_State ${PRODUCT_INST_ROOT_KEY} "${PRODUCT_INST_KEY}" "PersonalFolderIsMyDocument" 
    IntOP $Old_RdoBtn_MyDocument_Folder_State $RdoBtn_MyDocument_Folder_State + 0
    ;MessageBox MB_OK "Debug:Old_RdoBtn_MyDocument_Folder_State:$Old_RdoBtn_MyDocument_Folder_State"
    ReadRegStr $PersonalDataPath ${PRODUCT_INST_ROOT_KEY} "${PRODUCT_INST_KEY}" "PersonalFolderSelfDefined"
  ${Else}
    ;以前没有安装过彩虹，根据操作系统版本来初始化个人数据存放文件夹
    ;若为Vista操作系统则进行缺省设置为我的文档
    ${If} ${AtLeastWinVista}    
      IntOp $RdoBtn_MyDocument_Folder_State 1 + 0
    ${Else}
      IntOp $RdoBtn_MyDocument_Folder_State 0 + 0
    ${EndIf}        
  ${EndIf}

  ;设置安装所需空间增加15%
  Call SetAdditionalSectionSize  
FunctionEnd

;禁止多个安装实例
Function CheckSetupMultiRun
  System::Call 'kernel32::CreateMutex(i 0, i 0, t "EverFavSetup") i .r1 ?e'
  Pop $R0

  StrCmp $R0 0 +3
  MessageBox MB_OK|MB_ICONEXCLAMATION|MB_TOPMOST "      安装程序已经在运行。      "  
  Abort
FunctionEnd


;检查管理员权限
Function CheckAdminForInstall
  System::Alloc 6
  Pop $0
  System::Call "*$0(&i1 0, &i1 0, &i1 0, &i1 0, &i1 0, &i1 5)"
  System::Call "Advapi32::AllocateAndInitializeSid(i r0, i 2, i 32, i 544, i 0, i 0, i 0, i 0, i 0, i 0, *i .r1)"
  System::Call "Advapi32::CheckTokenMembership(i 0, i r1, *i .r2) i .r3"
  System::Call "Advapi32::FreeSid(i r1)"
  System::Free $0
  IntCmp $2 1 done_CheckAdmin 0 0
  !insertmacro Tip "您需要管理员权限才能执行安装程序" "${TITLE}"
  Abort
  done_CheckAdmin:
FunctionEnd

; GetWindowsVersion
;
; Based on Yazno's function, http://yazno.tripod.com/powerpimpit/
; Updated by Joost Verburg
;
; Returns on top of stack
;
; Windows Version (95, 98, ME, NT x.x, 2000, XP, 2003, Vista)
; or
; '' (Unknown Windows Version)
;
; Usage:
; Call GetWindowsVersion
; Pop $R0
; ; at this point $R0 is "NT 4.0" or whatnot
Function GetWindowsVersion
  Push $R0
  Push $R1

  ClearErrors

  ReadRegStr $R0 HKLM \
  "SOFTWARE\Microsoft\Windows NT\CurrentVersion" CurrentVersion

  IfErrors 0 lbl_winnt

  ; we are not NT
  ReadRegStr $R0 HKLM \
  "SOFTWARE\Microsoft\Windows\CurrentVersion" VersionNumber

  StrCpy $R1 $R0 1
  StrCmp $R1 '4' 0 lbl_error

  StrCpy $R1 $R0 3

  StrCmp $R1 '4.0' lbl_win32_95
  StrCmp $R1 '4.9' lbl_win32_ME lbl_win32_98

  lbl_win32_95:
  StrCpy $R0 '95'
  Goto lbl_done

  lbl_win32_98:
  StrCpy $R0 '98'
  Goto lbl_done

  lbl_win32_ME:
  StrCpy $R0 'ME'
  Goto lbl_done

  lbl_winnt:

  StrCpy $R1 $R0 1

  StrCmp $R1 '3' lbl_winnt_x
  StrCmp $R1 '4' lbl_winnt_x

  StrCpy $R1 $R0 3

  StrCmp $R1 '5.0' lbl_winnt_2000
  StrCmp $R1 '5.1' lbl_winnt_XP
  StrCmp $R1 '5.2' lbl_winnt_2003
  StrCmp $R1 '6.0' lbl_winnt_vista
  StrCmp $R1 '6.1' lbl_winnt_win7
  ${If} '6.1' S< $R1
  Goto lbl_winnt_win_high_unknow_version
  ${Else}
  Goto lbl_error
  ${EndIf}

  lbl_winnt_x:
  StrCpy $R0 "NT $R0 " 6
  Goto lbl_done

  lbl_winnt_2000:
  Strcpy $R0 '2000'
  Goto lbl_done

  lbl_winnt_XP:
  Strcpy $R0 'XP'
  Goto lbl_done

  lbl_winnt_2003:
  Strcpy $R0 '2003'
  Goto lbl_done

  lbl_winnt_vista:
  Strcpy $R0 'Vista'
  Goto lbl_done

  lbl_winnt_win7:
  Strcpy $R0 'Win7'
  Goto lbl_done

  lbl_winnt_win_high_unknow_version:
  Strcpy $R0 'AboveWin7Version'
  Goto lbl_done

  lbl_error:
  Strcpy $R0 ''
  lbl_done:

  Pop $R1
  Exch $R0
FunctionEnd

/**
Function GetPhotoUploaderDir
  StrCpy $InstallDirForPhotoUploader "$INSTDIR\..\PhotoUploader"
FunctionEnd
*/

;设置安装所需空间增加15%
Function SetAdditionalSectionSize
  ;Save existing register values to the stack
  Call PushAllGlobalVariable
  
  # increase required size of section 'MainSection' by 15%
  SectionGetSize ${MainSectionId} $0
  ;MessageBox MB_OK "Debug:${MainSectionId}:$0"

  ;MessageBox MB_OK "Debug:$0 "
  IntOp $2 $0 * 15 
  IntOp $2 $2 / 100

  IntOp $0 $0 + $2 
  ;MessageBox MB_OK "Debug:$0 "

  SectionSetSize ${MainSectionId} $0
  ;MessageBox MB_OK "Debug:${MainSectionId}:$0"

  ;Restore register values from the stack
  Call PopAllGlobalVariable
FunctionEnd

; 设置安装程序名称
Function SetOutFileName
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  Call GetLocalTime
  ; $0="01"      day
  ; $1="04"      month
  ; $2="2005"    year
  ; $3="Friday"  day of week name
  ; $4="16"      hour
  ; $5="05"      minute
  ; $6="50"      seconds
  Pop $0
  Pop $1
  Pop $2
  Pop $3
  Pop $4
  Pop $5
  Pop $6  

  ;MessageBox MB_OK|MB_TOPMOST 'Debug:Date=$0/$1/$2 ($3)$\nTime=$4:$5:$6'  
  ;Restore register values from the stack
  Call PopAllGlobalVariable
FunctionEnd

; 设置安装时间到注册表中
Function SetInstallTime
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  Call GetLocalTime
  ; $0="01"      day
  ; $1="04"      month
  ; $2="2005"    year
  ; $3="Friday"  day of week name
  ; $4="16"      hour
  ; $5="05"      minute
  ; $6="50"      seconds
  Pop $0
  Pop $1
  Pop $2
  Pop $3
  Pop $4
  Pop $5
  Pop $6

  StrCpy $9 "$2-$1-$0 $4:$5:$6"

  WriteRegStr ${PRODUCT_INST_ROOT_KEY} "${PRODUCT_INST_KEY}" "InstallTime" "$9"

  ;System::Call "kernel32::time(i 0) .r3"
  ;MessageBox MB_OK|MB_TOPMOST 'Debug:Date=$3'

  ;MessageBox MB_OK|MB_TOPMOST 'Debug:Date=$9'
  ;Restore register values from the stack
  Call PopAllGlobalVariable
FunctionEnd

;----------------------------------------------------------------------------
; Superseded by     : GetTime function.
;----------------------------------------------------------------------------
; Title             : Get Local Time
; Short Name        : GetLocalTime
; Last Changed      : 22/Feb/2005
; Code Type         : Function
; Code Sub-Type     : One-way Output
;----------------------------------------------------------------------------
; Required          : System plugin.
; Description       : Gets the current local time of the user's computer
;----------------------------------------------------------------------------
; Function Call     : Call GetLocalTime
;
;                     Pop "$Variable1"
;                       Day.
;
;                     Pop "$Variable2"
;                       Month.
;
;                     Pop "$Variable3"
;                       Year.
;
;                     Pop "$Variable4"
;                       Day of the week name.
;
;                     Pop "$Variable5"
;                       Hour.
;
;                     Pop "$Variable6"
;                       Minute.
;
;                     Pop "$Variable7"
;                       Second.
;----------------------------------------------------------------------------
; Author            : Diego Pedroso
; Author Reg. Name  : deguix
;----------------------------------------------------------------------------
 
Function GetLocalTime
 
  # Prepare variables
  Push $0
  Push $1
  Push $2
  Push $3
  Push $4
  Push $5
  Push $6
 
  # Call GetLocalTime API from Kernel32.dll
  System::Call '*(&i2, &i2, &i2, &i2, &i2, &i2, &i2, &i2) i .r0'
  System::Call 'kernel32::GetLocalTime(i) i(r0)'
  System::Call '*$0(&i2, &i2, &i2, &i2, &i2, &i2, &i2, &i2)i \
  (.r4, .r5, .r3, .r6, .r2, .r1, .r0,)'
 
  # Day of week: convert to name
  StrCmp $3 0 0 +3
    StrCpy $3 Sunday
      Goto WeekNameEnd
  StrCmp $3 1 0 +3
    StrCpy $3 Monday
      Goto WeekNameEnd
  StrCmp $3 2 0 +3
    StrCpy $3 Tuesday
      Goto WeekNameEnd
  StrCmp $3 3 0 +3
    StrCpy $3 Wednesday
      Goto WeekNameEnd
  StrCmp $3 4 0 +3
    StrCpy $3 Thursday
      Goto WeekNameEnd
  StrCmp $3 5 0 +3
    StrCpy $3 Friday
      Goto WeekNameEnd
  StrCmp $3 6 0 +2
    StrCpy $3 Saturday
  WeekNameEnd:
 
  # Minute: convert to 2 digits format
  IntCmp $1 9 0 0 +2
    StrCpy $1 '0$1'
 
  # Second: convert to 2 digits format
  IntCmp $0 9 0 0 +2
    StrCpy $0 '0$0'
 
  # Return to user
  Exch $6
  Exch
  Exch $5
  Exch
  Exch 2
  Exch $4
  Exch 2
  Exch 3
  Exch $3
  Exch 3
  Exch 4
  Exch $2
  Exch 4
  Exch 5
  Exch $1
  Exch 5
  Exch 6
  Exch $0
  Exch 6 
FunctionEnd

;安装vc 2008的一些dll库,并给用户提示是否要安装这些dll
Function InstallDll
  ;MessageBox MB_YESNO "Debug:恭喜，安装成功，低版本操作系统会缺少彩虹所需系统dll,是否安装这些系统dll？" IDNO NoInstallDll
  ExecWait "$INSTDIR\vcredist_x86.exe"
  NoInstallDll:
FunctionEnd

;静默安装程序执行的初始化代码
Function OnSilentInit
  ;MessageBox MB_OK "Debug:OnSilentInit"
  ;设置安装路径，由于已经使用了InstallDirRegKey所以会自动拿注册表中的值来作为安装路径
  ;设置个人数据保存文件夹
  Call InstallInitCheck
FunctionEnd

;静默安装程序执行的安装成功结束代码
Function OnSilentFini
  ;MessageBox MB_OK "Debug:OnSilentFini"
  ;快捷方式的创建
  ;进行注册表写入等工作
  Call OnFinishPageLeave
  
  ;自动运行彩虹
  Exec "$INSTDIR\EverFav.exe"
FunctionEnd

/***********************************下面为NSIS回调函数***********************************/
Function .onInit
  ;MessageBox MB_OK "Debug:.onInit"

  /*****************************************************************************************/
  IfSilent LabelSilent LabelNotSilent
LabelSilent:
  Call OnSilentInit
  GoTo LabelDone
LabelNotSilent:
  GoTo LabelDone
LabelDone:
  /*****************************************************************************************/

FunctionEnd

Function OnGUIInit
  ;MessageBox MB_OK "Debug:OnGUIInit"
  Call InstallInitCheck
FunctionEnd

Var Dialog
; 安装目录的控件句柄
Var hwndMyInstallDir
Var hwndMyInstallDirBrowserBtn
Var hwndRdoBtnInstallDir
var hwndRdoBtnMyDocument
; 个人数据存放目录的控件句柄
Var hwndMyDataDir
Var hwndMyDataDirBrowserBtn
; 可用空间
Var hwndSpaceFree
Var hwndSpaceNeed
var hwndRdoBtnSelfDefine

; 目录文本框内容改变回调函数
Function OnCustomDirectoryTextChange
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ;MessageBox MB_OK "Debug:OnCustomDirectoryTextChange"
  ${NSD_GetText} $hwndMyInstallDir $InstallToPath
  ${GetRoot} $InstallToPath $0
  ${DriveSpace} "$0" "/D=F /S=B" $R0

  !insertmacro GetSizeTextByByte $R0 $R1
  ;MessageBox MB_OK "Debug:$InstallToPath 可用空间:$R1"
  ${NSD_SetText} $hwndSpaceFree "可用空间:$R1"

  ;Restore register values from the stack
  Call PopAllGlobalVariable
FunctionEnd

; 个人数字文件夹目录文本框内容改变回调函数
Function OnCustomDataDirectoryTextChange
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ${NSD_GetText} $hwndMyDataDir $PersonalDataPath
  ;MessageBox MB_OK "Debug:$PersonalDataPath"

  ;Restore register values from the stack
  Call PopAllGlobalVariable
FunctionEnd

; 个人数据设置在安装目录Radio Button的OnClick函数
Function OnCustomDirectoryRdoBtnInstallDirClick
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ${NSD_GetState} $hwndRdoBtnInstallDir $1
  ${If} $1 == ${BST_CHECKED}
    IntOp $RdoBtn_MyDocument_Folder_State 0 + 0
  ${EndIf}
  ;MessageBox MB_OK "Debug:$PersonalDataPath"

  Call OnCustomDirectoryRdoBtnSelfDefineNotify

  ;Restore register values from the stack
  Call PopAllGlobalVariable
FunctionEnd

; 个人数据设置在我的文档Radio Button的OnClick函数
Function OnCustomDirectoryRdoBtnMyDocumentClick
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ${NSD_GetState} $hwndRdoBtnMyDocument $1
  ${If} $1 == ${BST_CHECKED}
    IntOp $RdoBtn_MyDocument_Folder_State 1 + 0
  ${EndIf}
  ;MessageBox MB_OK "Debug:$PersonalDataPath"

  Call OnCustomDirectoryRdoBtnSelfDefineNotify

  ;Restore register values from the stack
  Call PopAllGlobalVariable
FunctionEnd

; 个人数据设置在自定义文件夹的Radio Button的OnClick函数
Function OnCustomDirectoryRdoBtnSelfDefineClick
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ${NSD_GetState} $hwndRdoBtnSelfDefine $1
  ${If} $1 == ${BST_CHECKED}
    IntOp $RdoBtn_MyDocument_Folder_State 2 + 0
  ${EndIf}
  ;MessageBox MB_OK "Debug:$PersonalDataPath"

  Call OnCustomDirectoryRdoBtnSelfDefineNotify

  ;Restore register values from the stack
  Call PopAllGlobalVariable
FunctionEnd

; 个人数据文件夹自定义RadioButoon内容改变回调函数
Function OnCustomDirectoryRdoBtnSelfDefineChange
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ;MessageBox MB_OK "Debug:OnCustomDirectoryRdoBtnSelfDefineChange"
  Call OnCustomDirectoryRdoBtnSelfDefineNotify

  ;Restore register values from the stack
  Call PopAllGlobalVariable
FunctionEnd

; 个人数据文件夹自定义RadioButoon内容改变回调函数
Function OnCustomDirectoryRdoBtnSelfDefineNotify
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ;MessageBox MB_OK "Debug:OnCustomDirectoryRdoBtnSelfDefineNotify"

  ;根据自定义数据文件夹RadioButton是否选上来设置用户是否可以设置自定义数据存放目录
  ${NSD_GetState} $hwndRdoBtnSelfDefine $0
  ${If} $0 ==  ${BST_CHECKED}
    EnableWindow $hwndMyDataDir 1
    EnableWindow $hwndMyDataDirBrowserBtn 1
  ${Else}
    EnableWindow $hwndMyDataDir 0  
    EnableWindow $hwndMyDataDirBrowserBtn 0
  ${EndIf}

  ;Restore register values from the stack
  Call PopAllGlobalVariable
FunctionEnd

Function OnCustomDirectoryPageCreate
  ;Save existing register values to the stack
  Call PushAllGlobalVariable
  ;MessageBox MB_OK "Debug:OnCustomDirectoryPageCreate" 

  ;首先修改顶层页面的Label属性
  !insertmacro MUI_HEADER_TEXT_INTERNAL 0x040D "选择安装位置"
  !insertmacro MUI_HEADER_TEXT_INTERNAL 0x040E "选择“${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION}”的安装文件夹。"

  nsDialogs::Create /NOUNLOAD 1018
  Pop $Dialog

  ${If} $Dialog == error
    Abort
  ${EndIf}
  
  ${NSD_CreateLabel} 0 0 450 30 "安装向导将安装“${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION}”到下列文件夹。要安装到不同的文件夹，单击[浏览(B)]进行选择。单击[安装(I)]开始安装。" 

  ${NSD_CreateGroupBox} 0 30 450 43 "程序安装目录"

  ;宏使用格式：${MyCreateDirRequest} "_Dirx" "_Diry" "_Dirwidth" "_Buttonx" "_Buttonwidth" "_Height" "_Dirtext" "_Buttontext" "_Title" "_Suffix"
  ;${MyCreateDirRequest} 50 '请选择安装“${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION}”的目录：' "C:\Program Files\CaiHong" ""
  
  ${MyCreateDirRequest} 16 23% 70% 343 84 12u "C:\Program Files\EverFav" "浏览(&B)..." '请选择安装“${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION}”的目录：'  ""
  Pop $hwndMyInstallDir
  Pop $hwndMyInstallDirBrowserBtn
  ${NSD_OnChange} $hwndMyInstallDir OnCustomDirectoryTextChange
      
  ${NSD_CreateLabel} 0 80 300 13 "所需空间:"
  Pop $hwndSpaceNeed
  ${NSD_CreateLabel} 0 95 300 13 "可用空间:"
  Pop $hwndSpaceFree 
  
  ; 个人文件夹设置的RadioButton和Group
  ${NSD_CreateGroupBox} 0 115 450 93 "个人文件夹"
  ${NSD_CreateLabel} 22 130  400 15 "选择个人文件夹(用于保存消息记录等数据)的保存位置"

  ; 设置保存到安装目录下RadioButton
  ${If} ${AtLeastWinVista}
    StrCpy $1 "保存到安装目录下(Vista或更高版本的系统不支持此选项)"
  ${Else}
    StrCpy $1 "保存到安装目录下"
  ${EndIf}
  ${NSD_CreateRadioButton} 22 145 90% 10u "$1"
  Pop $hwndRdoBtnInstallDir
  ${NSD_AddStyle} $hwndRdoBtnInstallDir ${WS_GROUP}
  ${NSD_OnClick} $hwndRdoBtnInstallDir OnCustomDirectoryRdoBtnInstallDirClick
  
  ; 设置保存到我的文档目录下RadioButton
  ${NSD_CreateRadioButton} 22 165 50% 10u "保存到$\"我的文档$\"(推荐)"
  Pop $hwndRdoBtnMyDocument
  ${NSD_OnClick} $hwndRdoBtnMyDocument OnCustomDirectoryRdoBtnMyDocumentClick
  
  ; 设置自定义我的文档目录下RadioButton
  ${NSD_CreateRadioButton} 22 185 58 10u "自定义"
  Pop $hwndRdoBtnSelfDefine
  ${NSD_OnChange} $hwndRdoBtnSelfDefine OnCustomDirectoryRdoBtnSelfDefineChange
  ${NSD_OnNotify} $hwndRdoBtnSelfDefine OnCustomDirectoryRdoBtnSelfDefineNotify
  ${NSD_OnClick} $hwndRdoBtnSelfDefine OnCustomDirectoryRdoBtnSelfDefineClick

  ;个人数据的目录
  
  ${MyCreateDirRequest} 80 183 250 343 84 12u "$PersonalDataPath" "浏览(&B)..." '请选择存放“${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION}”个人数据的目录：'  ""
  Pop $hwndMyDataDir
  Pop $hwndMyDataDirBrowserBtn
  ${NSD_OnChange} $hwndMyDataDir OnCustomDataDirectoryTextChange
  
  /********************************下面为一系列逻辑处理代码**********************************/
  ;设置所需空间Label
  SectionGetSize ${MainSectionId} $0
  ;将KB转换为字节
  IntOp $0 $0 * 1024
  ;MessageBox MB_OK "Debug:$0"
  !insertmacro GetSizeTextByByte $0 $1
  ${NSD_SetText} $hwndSpaceNeed "所需空间:$1"
  
  ;Vista以上版本disable掉将个人数据文件夹存放在安装目录的选项
  ${If} ${AtLeastWinVista}
    EnableWindow $hwndRdoBtnInstallDir 0
  ${EndIf}

  ;设置安装目录的路径,路径设置好可用空间Labe将在$hwndMyInstallDir的回调OnCustomDirectoryTextChange中自动设置好
  ${If} 1 == $IsInstalledAlready
    ${NSD_SetText} $hwndMyInstallDir $InstallToPath
  ${Else}
    ${If} "" == $InstallToPath
      StrCpy $InstallToPath $INSTDIR
    ${EndIf}
    ${NSD_SetText} $hwndMyInstallDir $InstallToPath
  ${EndIf}
  
  ;调用下面Check和UnCheck以执行回调OnCustomDirectorySelfDefineNotify
  ${NSD_Check} $hwndRdoBtnSelfDefine
  ${NSD_UnCheck} $hwndRdoBtnSelfDefine

  ;初始化个人数据选择路径
  ;MessageBox MB_OK "Debug:RdoBtn_MyDocument_Folder_State:$RdoBtn_MyDocument_Folder_State"
  ${Switch} $RdoBtn_MyDocument_Folder_State
  ${Case} 0
    ; 以前没有安装过或是安装过设置为缺省安装目录
    ${If} 1 == $IsInstalledAlready
      ${If} ${AtLeastWinVista}
        ${NSD_Check} $hwndRdoBtnMyDocument
        IntOP $RdoBtn_MyDocument_Folder_State 1 + 0
      ${Else}
        ${NSD_Check} $hwndRdoBtnInstallDir
      ${EndIf}
    ${Else}
      ${If} ${AtLeastWinVista}
        ${NSD_Check} $hwndRdoBtnMyDocument
      ${Else}
        ${NSD_Check} $hwndRdoBtnInstallDir
      ${EndIf}
    ${EndIf}
    ${Break}
  ${Case} 1
    ; 以前个人数据文件夹设置为我的文档
    ${NSD_Check} $hwndRdoBtnMyDocument
    ${Break}
  ${Case} 2
    ; 以前个人数据文件夹设置为自定义
    ${NSD_Check} $hwndRdoBtnSelfDefine
    ${Break}
  ${Default}
    ; do something
    ${Break}
  ${EndSwitch}

  ;主动执行回调OnCustomDirectorySelfDefineNotify，以设置自定义个人数据文件夹的disable状态
  Call OnCustomDirectoryRdoBtnSelfDefineNotify

  nsDialogs::Show

  ;Restore register values from the stack
  Call PopAllGlobalVariable
FunctionEnd

Function OnCustomDirectoryPageLeave
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ;MessageBox MB_OK "Debug:OnCustomDirectoryPageLeave"
  ; 将安装目录设置到$INSTDIR 变量
  ${NSD_GetText} $hwndMyInstallDir $InstallToPath
  StrCpy $INSTDIR $InstallToPath
  ;MessageBox MB_OK "Debug:$INSTDIR, $InstallToPath"

  ;检查安装目录的有效性
  !insertmacro CheckPath $InstallToPath $0
  ;MessageBox MB_OK "Debug:$0"
  ${If} $0 == ${CHECKPATH_EMPTY}
    MessageBox MB_OK|MB_ICONSTOP|MB_TOPMOST "安装路径不能为空，请重新选择！"
    SendMessage $hwndMyInstallDir ${EM_SETSEL} 0 -1
    ${NSD_SetFocus} $hwndMyInstallDir
    Abort
  ${ElseIf} $0 <> ${CHECKPATH_OK}
    MessageBox MB_OK|MB_ICONSTOP|MB_TOPMOST "请设置有效程序安装目录！";选中相应的文本
    SendMessage $hwndMyInstallDir ${EM_SETSEL} 0 -1
    ${NSD_SetFocus} $hwndMyInstallDir
    Abort
  ${EndIf}
  
  ;检查安装目录中是否含有非法字符
  !insertmacro CheckPathSymbol $InstallToPath $0
  ;MessageBox MB_OK "Debug:$0, $InstallToPath"
  ${If} $0 == ${CHECKPATHSYMBOL_FIRST_CHAR}
      MessageBox MB_OK|MB_ICONSTOP|MB_TOPMOST "请设置有效程序安装目录，路径首字符不能为\或/！"
      ;选中相应的文本
      SendMessage $hwndMyInstallDir ${EM_SETSEL} 0 -1
      ${NSD_SetFocus} $hwndMyInstallDir
      Abort
  ${ElseIf} $0 == ${CHECKPATHSYMBOL_SPECIAL_CHAR}
      MessageBox MB_OK|MB_ICONSTOP|MB_TOPMOST '请设置有效程序安装目录，路径中不能包含 * ? " < > |等字符！'
      ;选中相应的文本
      SendMessage $hwndMyInstallDir ${EM_SETSEL} 0 -1
      ${NSD_SetFocus} $hwndMyInstallDir
      Abort
  ${EndIf}

  ${NSD_GetText} $hwndMyDataDir $PersonalDataPath  
  ;若设置了自定义个人数据存放目录则进行目录有效性检查
  ${If} $RdoBtn_MyDocument_Folder_State == 2
    !insertmacro CheckPath $PersonalDataPath $0
    ${If} $0 == ${CHECKPATH_EMPTY}
      MessageBox MB_OK|MB_ICONSTOP|MB_TOPMOST "个人文件夹路径不能为空，请重新选择！"
      ;选中相应的文本
      SendMessage $hwndMyDataDir ${EM_SETSEL} 0 -1
      ${NSD_SetFocus} $hwndMyDataDir
      Abort
    ${ElseIf} $0 <> ${CHECKPATH_OK}
      MessageBox MB_OK|MB_ICONSTOP|MB_TOPMOST "请设置有效个人文件夹路径！"
      ;选中相应的文本
      SendMessage $hwndMyDataDir ${EM_SETSEL} 0 -1
      ${NSD_SetFocus} $hwndMyDataDir
      Abort
    ${EndIf}
  
    ;检查个人数据文件夹中是否含有非法字符
    !insertmacro CheckPathSymbol $PersonalDataPath $0
    ;MessageBox MB_OK "Debug:$0, $PersonalDataPath"
    ${If} $0 == ${CHECKPATHSYMBOL_FIRST_CHAR}
      MessageBox MB_OK|MB_ICONSTOP|MB_TOPMOST "请设置有效个人文件夹路径，路径首字符不能为\或/！"
      ;选中相应的文本
      SendMessage $hwndMyDataDir ${EM_SETSEL} 0 -1
      ${NSD_SetFocus} $hwndMyDataDir
      Abort
    ${ElseIf} $0 == ${CHECKPATHSYMBOL_SPECIAL_CHAR}
      MessageBox MB_OK|MB_ICONSTOP|MB_TOPMOST '请设置有效个人文件夹路径，路径中不能包含 * ? " < > |等字符！'
      ;选中相应的文本
      SendMessage $hwndMyDataDir ${EM_SETSEL} 0 -1
      ${NSD_SetFocus} $hwndMyDataDir
      Abort
    ${ElseIf} $0 == ${CHECKPATHSYMBOL_OK}
      ${If} ${AtLeastWinVista}
        ; 检测是否为系统目录
        !insertmacro CheckSysPath $PersonalDataPath $0 $1
        ${If} $1 == ${CHECKSYSPATH_SYS}
          MessageBox MB_OK|MB_ICONSTOP|MB_TOPMOST "$\"$0$\"是系统目录，Windows Vista及以上版本操作系统不能使用系统目录作为个人文件夹！"
          ;选中相应的文本
          SendMessage $hwndMyDataDir ${EM_SETSEL} 0 -1
          ${NSD_SetFocus} $hwndMyDataDir
          Abort
        ${EndIf}
      ${EndIf}
    ${EndIf}
  ${EndIf}

  ;MessageBox MB_OK "Debug:InstallDir:$INSTDIR, DataDir:$MyDataDir"
  ;Restore register values from the stack
  Call PopAllGlobalVariable
FunctionEnd

Function OnDirectoryPageShow
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ; 如果已经安装了，则不允许修改安装路径  
  StrCmp $IsInstalledAlready 1 0 done_CheckIfInstalled
  StrCpy $0 "#32770"
  System::Call "user32::FindWindowEx(i $HWNDPARENT, i 0, t r0, t) i .r3"
  GetDlgItem $0 $3 0x3fb
  StrCpy $1 $InstallToPath
  System::Call "user32::SetWindowText(i r0, t r1)"

  /** 应产品需求：修改允许用户选择不同目录安装,2008-11-17
  EnableWindow $0 0
  GetDlgItem $0 $3 0x3e9
  EnableWindow $0 0
  
  ;解决焦点的问题
  GetDlgItem $0 $HWNDPARENT 3
  EnableWindow $0 0
  SendMessage $HWNDPARENT ${WM_SETFOCUS} 0 0
  GetDlgItem $0 $HWNDPARENT 1
  SendMessage $0 ${WM_SETFOCUS} 0 0
  GetDlgItem $0 $HWNDPARENT 3
  EnableWindow $0 1
  */
  GoTo label_done
done_CheckIfInstalled:
  ;以前没有安装过彩虹的代码

label_done:
  ;调整Directory分页的界面
  Call ChangeDirectorPageShowUI

  ;Restore register values from the stack
  Call PopAllGlobalVariable
FunctionEnd

Function OnWelcomePageInit  
  ;MessageBox MB_OK "Debug:OnWelcomePageInit"
FunctionEnd

Function OnWelcomePagePre  
  ;MessageBox MB_OK "Debug:OnWelcomePagePre"
FunctionEnd

Function OnLicencePagePre
  ;若为从上一页回来，则记录上一页的信息
  ;记录个人数据文件夹选择信息
  StrCpy $0 "#32770"
  System::Call "user32::FindWindowEx(i $HWNDPARENT, i 0, t r0, t) i .r3"
  ;下面检测个人文件夹选择RadioBox是否存在，若不存在则表示不是从下一个页面退回来的,否则是
  GetDlgItem $1 $3 12346
  ${If} 0 != $1
    ;检查个人选择夹RadioBox是否Check上了
    System::Call "user32::IsDlgButtonChecked(i r3, i 12346) i .r4"
    ;MessageBox MB_OK "Debug:$4"
    ${If} 1 == $4
      IntOP $RdoBtn_MyDocument_Folder_State  1 + 0
    ${Else}
      IntOP $RdoBtn_MyDocument_Folder_State  0 + 0
    ${EndIf}
  ${EndIf}
  
  ;记录用户输入的目录
  GetDlgItem $1 $3 0x3fb
  ${If} 0 != $1
    System::Call "user32::GetWindowText(i r1, t .r2, i ${NSIS_MAX_STRLEN})"
    StrCpy $InstallToPath $2
    ;MessageBox MB_OK "Debug:$2 ${NSIS_MAX_STRLEN}"
  ${EndIf}  
FunctionEnd

Function OnDirectoryPageLeave
  StrCpy $0 "#32770"
  System::Call "user32::FindWindowEx(i $HWNDPARENT, i 0, t r0, t) i .r3"
  ;检查个人选择夹RadioBox是否Check上了
  System::Call "user32::IsDlgButtonChecked(i r3, i 12346) i .r4"
  ;MessageBox MB_OK "Debug:$4"
  ${If} 1 == $4
    IntOP $RdoBtn_MyDocument_Folder_State  1 + 0
  ${Else}
    IntOP $RdoBtn_MyDocument_Folder_State  0 + 0
  ${EndIf}
FunctionEnd

Function OnDirectoryPagePre
;  StrCpy $0 "#32770"
;  System::Call "user32::FindWindowEx(i $HWNDPARENT, i 0, t r0, t) i .r3"
;  ;检查个人选择夹RadioBox是否Check上了
;  System::Call "user32::IsDlgButtonChecked(i r3, i 12346) i .r4"
;  MessageBox MB_OK "Debug:$4"
;  ${If} 1 == $4
;    IntOP $RdoBtn_MyDocument_Folder_State  1 + 0
;  ${Else}
;    IntOP $RdoBtn_MyDocument_Folder_State  0 + 0
;  ${EndIf}
FunctionEnd

Function OnInstfilesPageShow  
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ;MessageBox MB_OK "Debug:OnInstfilesPageShow"
  ;RegDll $INSTDIR\RainBowInstallHelper.dll
  ;File "$INSTDIR\RainBowInstallHelper.dll"

  ;先检测判断相应dll是否被调用(RainBowInstallHelper.dll相关代码)
  #############################################################
  ;IntOp $0 0 + $HWNDPARENT
  ;StrCpy $1 "rainbowweb.dll"
  ;MessageBox MB_OK "Debug: StrCpy $$1 $$INSTDIR:$1"
;  System::Call "RainBowInstallHelper::InstallHelper(t r1)"

;  StrCpy $1 "rainbowweb2.dll"
  ;MessageBox MB_OK "Debug: StrCpy $$1 $$INSTDIR:$1"
;  System::Call "RainBowInstallHelper::InstallHelper(t r1)"
  #############################################################


  ;安装前先删除所有dll
  Delete "$INSTDIR\*.dll"  
  !insertmacro UninstallLibrary  

  ; Disable关闭菜单
  System::Call "user32::GetSystemMenu(i, i) i($HWNDPARENT, 0) .r0"
  System::Call "user32::EnableMenuItem(i r0, i 61536, i 1)"

  ;MessageBox MB_OK "Debug: IsInstalledAlready: $IsInstalledAlready, Old_RdoBtn_MyDocument_Folder_State:$Old_RdoBtn_MyDocument_Folder_State"

  ${If} ${AtLeastWinVista} 
  ${AndIf} $IsInstalledAlready == 1 
  ${AndIf} $Old_RdoBtn_MyDocument_Folder_State == 0
    ;检测原先的个人数据存放目录是否为系统目录
    ;!insertmacro CheckSysPath $InstalledPath $0 $1
    ;MessageBox MB_OK "Debug: InstalledPath:$InstalledPath, CheckSysPath:$0 $1"
    ;${If} $1 == ${CHECKSYSPATH_SYS}
      ;MessageBox MB_OK "Debug:$\"$0$\"是系统目录，Windows Vista及以上版本操作系统不能使用系统目录作为个人文件夹！"
      StrCpy $2 ""
      ;开始进行个人数据文件夹的迁移
      ${Switch} $RdoBtn_MyDocument_Folder_State
      ${Case} 0
        ; 本次个人数据文件夹设置为缺省安装目录，由于此次安装不会存在Vista下将个人数据文件夹设置为安装目录的情形，so do nothing...
      ${Break}
      ${Case} 1
        ; 本次个人数据文件夹设置为我的文档
        SetShellVarContext current
        StrCpy $2 "$DOCUMENTS\EverFav"
        SetShellVarContext all
        ;MessageBox MB_OK "Debug: 本次个人数据文件夹:$2"
        ${Break}
      ${Case} 2
        ; 本次个人数据文件夹设置为自定义
        StrCpy $2 "$PersonalDataPath\EverFav"
        ;MessageBox MB_OK "Debug: 本次个人数据文件夹:$2"
        ${Break}
      ${Default}
        ; do something
        ${Break}
      ${EndSwitch}

      ${If} $2 != ""        
        ;先释放文件，下面才能执行该文件
        SetOutPath $INSTDIR
        ;MessageBox MB_OK "Debug: OUTDIR:$OUTDIR"
        SetOverwrite on
        ;File "/oname=$INSTDIR\ShiftPersonalData.exe" "${SRC_DIR}\ShiftPersonalData.exe"
        SetOverwrite try
        ;MessageBox MB_OK "Debug: ShiftPersonalData.exe:$InstalledPath $2"
        Exec '"$INSTDIR\ShiftPersonalData.exe" "$InstalledPath " "$2 " '
      ${EndIf}
    ;${EndIf}    
  ${EndIf}

  ;Restore register values from the stack
  Call PopAllGlobalVariable
FunctionEnd

Function OnInstfilesPageLeave
  ;MessageBox MB_OK "Debug:OnInstfilesPageLeave"

  ;安装vc 2008的一些dll库,并给用户提示是否要安装这些dll
  ;Call InstallDll
  
  ;拷贝系统dll到系统目录下;
  ;Call CopySystemDll  

  ; 注册com组件dll
  SetOutPath $INSTDIR
  ClearErrors
  ;IntCmp $IsRainbowWebDllInUse 1 0 +3 +3
  /**
  ${If} $IsRainbowWebDllInUse == 1
    RegDll $INSTDIR\rainbowweb2.dll
  ${Else}
    RegDll $INSTDIR\rainbowweb.dll
  ${EndIf}

  ;目前强制注册rainbowweb2.dll
  RegDll $INSTDIR\rainbowweb2.dll
  ;IfErrors 0 +2
  ;MessageBox MB_OK "Debug:COM组件$\"$INSTDIR\rainbowweb.dll$\"注册失败,彩虹某些功能可能不能正常使用"
  RegDll $InstallDirForPhotoUploader\PhotoUploader.ocx
  ;注册MusicX.ocx控件
  RegDll $INSTDIR\MusicX.ocx
  ;注册RBShell.dll控件
  RegDll $INSTDIR\RBShell.dll
  */
  /**
  ;调用dll的函数将以前的自定义表情导入到新的自定义表情中
  ;设置自定义表情导入的源目录,下面变量为:-2表未安装彩虹, >=-1则表安装过彩虹
  ${If} -2 == $RainbowInstallVersionType
    ;未安装过彩虹
    ;检测是否安装过挂挂
    ${If} $IsGGInstalledAlready == 1
      StrCpy $0 $GGInstalledPath
      ;MessageBox MB_OK "Debug: StrCpy $$0 $$GGInstalledPath:$0"
    ${Else}
      ;没装过彩虹也没有装过挂挂
      Goto done
    ${EndIf}    
  ${ElseIf} $RainbowInstallVersionType >= -1
    ;安装过彩虹
    StrCpy $0 $InstalledPath 
    ;MessageBox MB_OK "Debug: StrCpy $$0 $$InstalledPath:$0"
  ${EndIf}
  
  ;设置自定义表情导入的目的目录
  ${If} 1 == $RdoBtn_MyDocument_Folder_State
    SetShellVarContext current
    StrCpy $1 "$DOCUMENTS\51\Rainbow\"    
    ;MessageBox MB_OK "Debug: 1 == $$RdoBtn_MyDocument_Folder_State:$1"
    SetShellVarContext all
  ${Else}    
    StrCpy $1 $INSTDIR
    ;MessageBox MB_OK "Debug: StrCpy $$1 $$INSTDIR:$1"
  ${EndIf}  
  System::Call "CompatEmotion::ShiftEmoProfileWarper(t r0, t r1)"
  */
done:
  ;设置安装时间到注册表中
  Call SetInstallTime
FunctionEnd

Function OnFinishPagePre
  ;MessageBox MB_OK "Debug:OnFinishPagePre"
FunctionEnd

Function OnFinishPageShow
  ; Disable取消按钮
  GetDlgItem $0 $HWNDPARENT 2
  EnableWindow $0 0
  
  ;将安装窗口置前
  BringToFront

  ; 创建开机启动Rainbow checkbox
  /* StrCpy $0 "#32770"
  System::Call "user32::FindWindowEx(i $HWNDPARENT, i 0, t r0, t) i .r3"
  System::Call "user32::GetWindow(i r3, i 2) i .r4"
  StrCpy $0 "BUTTON"
  StrCpy $1 "开机时自动启动Rainbow"
  System::Call "user32::CreateWindowEx(i 0, t r0, t r1, i 1342177283, i 180, i 165, i 200, i 20, i r4, i 12345, i 0, i 0) i .r5"
  System::Call "user32::CheckDlgButton(i r4, i 12345, i 1)"
  SetCtlColors $5 0x0 0x00ffffff
  CreateFont $0 "宋体" 9
  SendMessage $5 ${WM_SETFONT} $0 1
  */
  ; 创建设置主页 checkbox
  /*StrCpy $0 "#32770"
  System::Call "user32::FindWindowEx(i $HWNDPARENT, i 0, t r0, t) i .r3"
  System::Call "user32::GetWindow(i r3, i 2) i .r4"
  StrCpy $0 "BUTTON"
  StrCpy $1 "把www.caihong.com/index.php设为主页"
  System::Call "user32::CreateWindowEx(i 0, t r0, t r1, i 1342177283, i 180, i 225, i 200, i 20, i r4, i 12346, i 0, i 0) i .r5"
  System::Call "user32::CheckDlgButton(i r4, i 12346, i 1)"
  SetCtlColors $5 0x0 0x00ffffff
  CreateFont $0 "宋体" 9
  SendMessage $5 ${WM_SETFONT} $0 1
  */
FunctionEnd

Function OnFinishPageLeave
  ;Save existing register values to the stack
  Call PushAllGlobalVariable

  ;MessageBox MB_OK "Debug:OnFinishPageLeave"
  ; 开机自启动
  ; WriteRegStr HKLM "SOFTWARE\Microsoft\Windows\CurrentVersion\Run" "Rainbow" "$INSTDIR\caihong.exe"

  ; 检查开机启动Rainbow checkbox
  /* StrCpy $0 "#32770"
  System::Call "user32::FindWindowEx(i $HWNDPARENT, i 0, t r0, t) i .r3"
  System::Call "user32::IsDlgButtonChecked(i r3, i 12345) i .r4"
  IntCmp $4 0 done_AutoStartRainbow AutoStartRainbow AutoStartRainbow
  */
AutoStartRainbow:
  ;MessageBox MB_OK "Debug:AutoStartRainbow:"
  /*由于会和彩虹的系统设置对话框中自动启动相冲突，因此禁掉下面的代码
  WriteRegStr HKLM "SOFTWARE\Microsoft\Windows\CurrentVersion\Run" "Rainbow" "$INSTDIR\caihong.exe"
  */
  /** 删除以前版本设置的注册表中的自动启动键值
  防止开机时启动多个实例
  */
  DeleteRegValue HKLM "SOFTWARE\Microsoft\Windows\CurrentVersion\Run" "EverFav"
done_AutoStartRainbow: 
  ;MessageBox MB_OK "Debug:done_AutoStartRainbow:"
  ; 检查设置主页 checkbox
  StrCpy $0 "#32770"
  System::Call "user32::FindWindowEx(i $HWNDPARENT, i 0, t r0, t) i .r3"
  System::Call "user32::IsDlgButtonChecked(i r3, i 12346) i .r4"
  IntCmp $4 0 done_SetHomePage SetHomePage SetHomePage
  SetHomePage:
  WriteRegStr HKLM "SOFTWARE\Microsoft\Internet Explorer\Main" "Start Page" "www.everfav.com/index.php"
  WriteRegStr HKCU "SOFTWARE\Microsoft\Internet Explorer\Main" "Start Page" "www.everfav.com/index.php"
done_SetHomePage:
  ;MessageBox MB_OK "Debug:done_SetHomePage:"
  ; 将版本，安装路径等写入注册表
  WriteRegStr ${PRODUCT_INST_ROOT_KEY} "${PRODUCT_INST_KEY}" "Install" "$INSTDIR"
  WriteRegStr ${PRODUCT_INST_ROOT_KEY} "${PRODUCT_INST_KEY}" "Version" "${PRODUCT_VERSION_INFO}"

  ; 将用户个人数据保存文件夹选项写入注册表,0:表在程序安装目录下,1:表在MyDocument目录下,2:表自定义
  WriteRegStr ${PRODUCT_INST_ROOT_KEY} "${PRODUCT_INST_KEY}" "PersonalFolderIsMyDocument" "$RdoBtn_MyDocument_Folder_State"
  ${If} $RdoBtn_MyDocument_Folder_State == 2
    WriteRegStr ${PRODUCT_INST_ROOT_KEY} "${PRODUCT_INST_KEY}" "PersonalFolderSelfDefined" "$PersonalDataPath"
  ${EndIf}

  ; 设置windows防火墙例外(WinXP及更高版本)
  Call GetOsVersion
  Pop $1    ;main ver
  Pop $2    ;sub ver
  IntCmp $1 5 0 done_SetFirewallException SetFirewallException_WinVista
  IntCmp $2 0 done_SetFirewallException
SetFirewallException_WinXP:
  ;MessageBox MB_OK "Debug:SetFirewallException_WinXP:"
  WriteRegStr HKLM "SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\StandardProfile\AuthorizedApplications\List" \
    "$INSTDIR\EverFav.exe" "$INSTDIR\EverFav.exe:*:Enabled:EverFav"
  Goto done_SetFirewallException
SetFirewallException_WinVista:
  ;MessageBox MB_OK "Debug:SetFirewallException_WinVista:"
  WriteRegStr HKLM "SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\FirewallRules" \
    "TCP Query User{DADCADEF-5FC1-4432-8728-450EEA09698D}$INSTDIR\EverFav.exe" \
    "v2.0|Action=Allow|Active=TRUE|Dir=In|Protocol=6|Profile=Private|App=$INSTDIR\EverFav.exe|Name=${PRODUCT_NAME}|Desc=${PRODUCT_NAME}|Edge=FALSE|"
  WriteRegStr HKLM "SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\FirewallRules" \
    "UDP Query User{EBDA0184-B16F-482E-914E-FD556FAE80BD}$INSTDIR\EverFav.exe" \
    "v2.0|Action=Allow|Active=TRUE|Dir=In|Protocol=17|Profile=Private|App=$INSTDIR\EverFav.exe|Name=${PRODUCT_NAME}|Desc=${PRODUCT_NAME}|Edge=FALSE|"
done_SetFirewallException:
  ;MessageBox MB_OK "Debug:done_SetFirewallException:"
  ; 把ActiveX控件加到受信任列表(for IE7)
  ; WriteRegStr HKLM "SOFTWARE\Microsoft\Windows\CurrentVersion\Ext\PreApproved\{C7AA3061-C959-4D65-B029-DC6FA761FD16}" "" ""
  WriteRegStr HKLM "SOFTWARE\Microsoft\Windows\CurrentVersion\Ext\PreApproved\{C7AA3061-C959-4D65-B029-DC6FA761FDDD}" "" ""
  
done:  
  ;MessageBox MB_OK "Debug:done:"
  ;最后一次插件调用必须没有 /NOUNLOAD 参数，否则 NSIS 将不能在安装结束后释放相应的DLL 文件
  SetPluginUnload manual
  
  ;调用安装统计
  StrCpy $0 $INSTDIR
  System::Call "gt::gt(i 1, t r0) ? u"

  ;什么都不作 (目的就是为了卸载 System.dll)
  System::Free 0

  ;Restore register values from the stack
  Call PopAllGlobalVariable
FunctionEnd

Function .onInstFailed
  ;MessageBox MB_OK "Debug:.onInstFailed"
  MessageBox MB_OK "安装失败,请尝试重启机器后再安装！"
FunctionEnd
  
Function .onInstSuccess  
  ;MessageBox MB_OK "Debug:.onInstSuccess"

  /*****************************************************************************************/
  ;设置静默安装要执行的代码
  IfSilent LabelSilent LabelNotSilent
LabelSilent:
  Call OnSilentFini
  GoTo LabelDone
LabelNotSilent:
  GoTo LabelDone
LabelDone:
  /*****************************************************************************************/

  ; 最后一次插件调用必须没有 /NOUNLOAD 参数，否则 NSIS 将不能在安装结束后删除
  ; 临时的 DLL 文件
  SetPluginUnload manual
  ; 什么都不作 (目的就是为了卸载 System.dll)
  System::Free 0
  ;MessageBox MB_OK "Debug:.onInstSuccess"
FunctionEnd

/****************************下面为反安装代码******************************/
; Uninstaller pages
;!define MUI_PAGE_CUSTOMFUNCTION_PRE un.SetTitle
;!define MUI_PAGE_CUSTOMFUNCTION_SHOW un.SetTitle
;!define MUI_PAGE_CUSTOMFUNCTION_LEAVE un.SetTitle
;!insertmacro MUI_UNPAGE_WELCOME
!define MUI_PAGE_CUSTOMFUNCTION_PRE un.SetTitle
!define MUI_PAGE_CUSTOMFUNCTION_SHOW un.SetTitle
!define MUI_PAGE_CUSTOMFUNCTION_LEAVE un.SetTitle
!insertmacro MUI_UNPAGE_CONFIRM
!define MUI_PAGE_CUSTOMFUNCTION_PRE un.SetTitle
!define MUI_PAGE_CUSTOMFUNCTION_SHOW un.OnInstallFileShow
!define MUI_PAGE_CUSTOMFUNCTION_LEAVE un.SetTitle
!insertmacro MUI_UNPAGE_INSTFILES
;!define MUI_PAGE_CUSTOMFUNCTION_PRE un.OnFinishPagePre
;!define MUI_PAGE_CUSTOMFUNCTION_SHOW un.SetTitle
;!define MUI_PAGE_CUSTOMFUNCTION_LEAVE un.SetTitle
;!insertmacro MUI_UNPAGE_FINISH

; Language files
!insertmacro MUI_LANGUAGE "SimpChinese"

; Reserve files
!insertmacro MUI_RESERVEFILE_INSTALLOPTIONS

; 检测文件被某个进程使用的dll(RainBowInstallHelper.dll相关代码)
; ReserveFile "${SRC_DIR}\RainBowInstallHelper.dll"
;ReserveFile "${SRC_DIR}\ShiftPersonalData.exe"

; MUI end ------

/******************************************下面为反安装函数********************************************/
;禁止多个反安装实例
Function un.CheckUninstallMultiRun
  System::Call 'kernel32::CreateMutex(i 0, i 0, t "RainbowUninstall") i .r1 ?e'
  Pop $R0

  StrCmp $R0 0 +3
  MessageBox MB_OK|MB_ICONEXCLAMATION|MB_TOPMOST "      卸载程序已经在运行。      "
  Abort
FunctionEnd

Function un.SetTitle
  StrCpy $0 "${UNTITLE}"
  System::Call "user32::SetWindowText(i $HWNDPARENT, t r0)"
FunctionEnd

/******************************************下面为反安装回调函数***************************************/
Function un.onInit
  ;MessageBox MB_OK "Debug:un.onInit"  
FunctionEnd

Function un.OnUNGUIInit
  ;MessageBox MB_OK "Debug:un.OnUNGUIInit"
  Call un.UninstallInitCheck
FunctionEnd

; 卸载前检查函数
Function un.UninstallInitCheck
  ;禁止多个安装实例
  Call un.CheckUninstallMultiRun

  ;检查管理员权限
  System::Alloc 6
  Pop $0
  System::Call "*$0(&i1 0, &i1 0, &i1 0, &i1 0, &i1 0, &i1 5)"
  System::Call "Advapi32::AllocateAndInitializeSid(i r0, i 2, i 32, i 544, i 0, i 0, i 0, i 0, i 0, i 0, *i .r1)"
  System::Call "Advapi32::CheckTokenMembership(i 0, i r1, *i .r2) i .r3"
  System::Call "Advapi32::FreeSid(i r1)"
  System::Free $0
  IntCmp $2 1 done_CheckAdmin 0 0
  !insertmacro Tip "您需要管理员权限才能执行卸载程序" "${UNTITLE}"
  Abort
  done_CheckAdmin:

  ; 检查是否正在运行
  find_instance:
  /**
  return on $R0: 
  1 - the process was found 
  0 - the process was not found  
  */
  
  Processes::FindProcess "EverFav.exe"
  ;MessageBox MB_OK "Debug:Processes::FindProcess$R0"
  ${If} $R0 == 1
    ;MessageBox MB_OK "Debug:Processes::FindProcess caihong.exe"
    !insertmacro MsgBox "${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION}正在运行,请先退出,再重试" "${UNTITLE}" 0x45
    ${If} $9 == 4
      GoTo find_instance
    ${Else}
      Abort
    ${EndIf}
  ${EndIf}

;  !insertmacro IsRainbowRunning
;  IntCmp $9 1 0 done_CheckIsRunning done_CheckIsRunning
;  !insertmacro MsgBox "${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION}正在运行,请先退出,再重试" "${UNTITLE}" 0x45
;  IntCmp $9 4 find_instance 0 0
;  Abort
  done_CheckIsRunning:

  CheckUpdateRunning:
    !insertmacro IsUpdateRunning
    IntCmp $9 1 0 done_CheckUpdateRunning
    !insertmacro Tip "EverFav升级程序正在运行，现在无法进行卸载" "${UNTITLE}"
    Abort
  done_CheckUpdateRunning:
FunctionEnd

Function un.onUninstSuccess
  
  ;修改卸载页面的关闭按钮text为完成
  !insertmacro MUI_HEADER_TEXT_INTERNAL 1 "完成(&F)"

  ;卸载用户调查页面
  ExecShell "open" "http://www.everfav.com/uninstall.php"
  ;ExecShell "" "iexplore.exe" "http://www.caihong.com/uninstall.php"

  HideWindow
  ;!insertmacro Tip "${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION} 已成功地从您的计算机移除。" "${UNTITLE}"
  ;!insertmacro MsgBox "${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION} 已成功地从您的计算机移除。" "${UNTITLE}" MB_OK|MB_TOPMOST|MB_SETFOREGROUND
  MessageBox MB_OK|MB_TOPMOST|MB_SETFOREGROUND "${PRODUCT_NAME_CHINESE} ${PRODUCT_VERSION} 已成功地从您的计算机移除。"
  
  ;最后一次插件调用必须没有 /NOUNLOAD 参数，否则 NSIS 将不能在安装结束后删除临时的 DLL 文件
  SetPluginUnload manual
  
  ;什么都不作 (目的就是为了卸载 System.dll)
  System::Free 0
  
  ;最后删除掉gt.dll
  Delete "$INSTDIR\gt.dat"
  Delete "$INSTDIR\gt.dll"
FunctionEnd

Function un.OnInstallFileShow
  ;MessageBox MB_OK "Debug:un.OnInstallFileShow"
  Call un.SetTitle
  ;修改卸载页面的关闭按钮text为完成
  !insertmacro MUI_HEADER_TEXT_INTERNAL 1 "完成(&F)"  
FunctionEnd

Function un.OnFinishPagePre
  ;MessageBox MB_OK "Debug:un.OnFinishPagePre"
  Call un.SetTitle
  ;修改卸载页面的关闭按钮text为完成
  !insertmacro MUI_HEADER_TEXT_INTERNAL 1 "完成(&F)"
FunctionEnd
